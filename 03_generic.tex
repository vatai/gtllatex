\section{Generikus programozás és az STL}
A konténereket és a rajtuk végrehajtandó algoritmusokat C++-ban nagyon elegáns módon oldották meg,  osztály-sablon\-ok és függvények-sablon\-ok segít\-ségével. A C++ STL könyvtárában (Standard Template Library), a konté\-nerek mint például a \verb'vector', a \verb'list', a \verb'set' stb. mind osztály-sablonok, melyeket a tárolandó elemek típusával paramétere\-zünk. Ezek mellé, az STL még a megfelelõ algoritmusokat is biztosítja, mint például a \verb'sort' vagy a \verb'find'. Az algoritmusok függvény sablonként vannak implementálva, és iterátorokon keresztül ``kommunikálnak'' a konténerek\-kel. Az STL-nek megközelítése számos elõnye van az \verb'Object'eket tároló konténerrel szemben:
\begin{itemize}
	\item Típus biztonságos: A fordító mindent elvégez helyettünk. Fordítási-idõben példányosítja a osztály-sablonokat és függvény-sablonokat, és a megfelelõ típus ellenõrzéseket is elvégzi. Tehát kisebb a hiba lehetõség.
	\item Hatékony: A sablonok segítségével a fordító mindent a fordítási idõben kiszámol, leellenõriz és behelyettesít -- minden a fordításkor eldõl semmit sem hagy futási-idõre.
	\item Egyszerûbb bõvíteni és programozni: akár új algoritmusokkal, akár új konténerekkel egyszerûen bõvíthetjük a könyvtárat, csak a megfelelõ iterátorokat kell implementálni és a megfelelõ konvenciókat (concept-eket) követni. 
\end{itemize}
Az utobbiból az is adódik, hogy ha van $m$ típusunk és $n$ mûveletünk, akkor az objektum orientál hozzáállással ellentétben, ahol minden típus minden (virtuális) metódusát, azaz $O(n*m)$ függvényt kell implementálni, generikus programozással viszont elég $O(n+m)$, vagyis külön-külön implementálnunk kell a típusokat (és iterátoraikat) és külön az algoritmusokat.

Ezek az elõnyöket, az STL oly módon képes megvalósítani, hogy egyálta\-lán nem megy a programozó rovására, vagyis nem kell bonyolultabb kódot írni, sõt, kevesebb kódot kell írni, ami kevesebb hibával jár. A C++ sablonok, fordításkor manipulálják a kódot, és egy csomó rutin munkát elvégeznek a programozó helyett. Ebben az esetben, ahelyett, hogy mi írjuk meg külön-külön a \verb'IntVector'-t és a \verb'FloatVectort', a sablonok ezt automatikusan megteszik helyettünk, ugyanis lényegében ugyan azt a kódot kell megírni, csak más típussal.

%%%%% A GTL elkészítését az ösztönözte, hogy az alakzatok konténerekre, az transzformációs mûveletek pedig algoritmusokra hasonlítanak. A GTL úgy van felépítve mintha pontokat (pontosabban \verb'vect<T>' típusú elemeket) tároló konténerek lennének, és az alakzatok iterátorai ezeken a pontokon, azaz a csúcsokon iterálnak végig. 	