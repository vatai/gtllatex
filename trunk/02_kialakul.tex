\section{A Generikus programozás kialakulása}
A C++ elsõ kereskedelmi forgalomba hozatalakor, 1985-ben még nem támo\-gatta a generikus programozást, mivel nem volt benne sablon mechanizmus. A sablonokat csak késõbb építették be a nyelvbe, ezzel lehetõvé téve a generikus programozás kialakulását.
\subsection{Egy kézenfekvõ megoldás -- öröklõdés}
Ha az ember geometriai alakzatokat rajzoló és manipuláló programot akar írni, akkor az objektum orientált megközelítés, vagyis az öröklõdés jó vá\-lasz\-tás\-nak tûnik. A tipikus példa, az öröklõdés és az objektum orientált programozás szemléltetésére pontosan az ilyen rajzoló programok implementációja. Egy \verb'Shape' bázis-osztályból indulunk ki és ebbõl származtatjuk a \verb'Polygon', \verb'Circle' és hasonló osztályokat. A \verb'Shape' osztályban deklaráljuk a virtuális \verb'draw', \verb'move', \verb'rotate', stb. metódusokat, majd a származtatott osztályokban definiáljuk õket. Egy \verb'Shape*' típusú, azaz alakzatokra mutató mutatókat tároló tömbbe pakoljuk a rajzlap tartalmát, melyet egy \verb|DrawAll| függvénnyel rajzolunk ki, amely a tömb minden elemére meghívja a megfelelõ alagzat virtuális \verb|draw| metódusát. Ilyen megoldással erõsen tá\-masz\-kodunk az öröklõ\-désre és a dinamikus polimorfizmusra.

A Java elsõ kiadásai ezt a megközelítést alkalmazták a szabványos tárolók megvalósításához. Jávában minden típus az \verb|Object| típusból származik, azaz Jávában ``minden \verb|Object|'' \cite{tij}. Kézenfekvõ volt az a megoldás, hogy az \verb'ArrayList', a \verb'List', a \verb'Set' és a \verb'Map'-hez hasonló konténerek \verb'Object' típusú elemeket (pontosabban referenciákat) tárolnak. Ennek egyértelmû hátránya volt, hogy a tárolók úgymond nem ``tudtak'' a tárolt elemek tí\-pusáról semmit, így nem igazán lehet a konténer méretének  és az elemek (\verb|Object| típusú referenciájának) lekérdezésén kívül mást tenni. Ez könnyen megoldható egy-egy új ``típus-tudatos'' osztály bevezetésével:
\begin{verbatim}
    public class ShapeList {
      private List list = new ArrayList();
      public void add(Shape sh) { list.add(sh); }
      public Shape get(int index) {
        return (Shape)list.get(index); // konverzió
      }
      public int size() { return list.size(); }
    } 
\end{verbatim}

Így már ``típus-tudatos'' a \verb|Shape| listánk, de minden típus-konténer párra ezt végig kellene csinálni, és lényegében ugyan azt a kódot írnánk le, csak például \verb|ArrayList| helyett \verb|Set| szerepelne és a \verb"Shape" helyet egy másik típus. Ez egy elég unalmas monoton munka, amibe az ember gyorsan belefárad, tehát könnyen hibázhat, viszont nagyon úgy tûnik, hogy egy számítógép könnyen el tudná végezni ezt a feladatot. 
%% Még nem is említettük meg a futás idejû pazarlást ami a \verb|get()| hívásakor végrehajtott dinamikus típuskonverzió eredményez és az alakzatok virtuális függvény hívásainak költségét. 

A C++ támogatja a típusos tömböket, így C++-ban nem lenne szükség a \verb|ShapeList| osztályra, elég lenne egy \verb|Shape* shapes[];| változó. Gyorsan belátnánk, hogy az alakzatokat, tömbben tárolni, ami egy összefüggõ tárterület a memóriában, nem lesz hosszútávon túl szerencsés megoldás. Az új alakzatok hozzáadásával szükség lesz a tömb dinamikus bõvítésére, vagyis jobb lenne ha egy könnyen és hatékonyan bõvíthetõ listában tárolnánk az alakzatokat. Viszont szigorúan a C++ nyelvben, nincs beleépítve a láncolt lista, így azt vagy magunk implementáljuk, vagy egy elõre megírt könyvtár segítségéhez fordulunk. Sajnos a második út a C++-ban, a sablonok bevezetése elõtt nem igazán volt járható, vagyis, visszatértünk az elõzõ \verb|ShapeList| problémához, ugyanis nagy valószínûséggel a lista elemeit \verb|void*| típussal deklarálták a könyvtár írói, hogy tetszõleges típusú elemet tudjon tárolni és újra nem tud a lista semmit a tárolt elem típusáról. Tehát akár melyik utat választjuk, akár saját lista implementációt, akár egy elõre megírt \verb|void*|-okat tároló listát választunk, nem kerülhetjük ki a lista típusossá tételéhez szükséges extra programozást, ami egyúttal hibaforrás is lehet, legalábbis ez volt a helyzet a sablonok bevezetése elõtt.

\subsection{Az elsõ generikus C++ könyvtár}
A konténereket és a rajtuk végrehajtandó algoritmusokat C++-ban nagyon elegáns módon oldották meg,  osztály-sablon\-ok és függvények-sablon\-ok segít\-ségével. A C++ STL könyvtárában (Standard Template Library, ami ma már része a C++ szabványnak), a konté\-nerek (\verb'vector', \verb'list', \verb'set' stb.) mind osztály-sablonok, melyeket a tárolandó elemek típusával paraméterez\-hetünk. Ezek mellé, az STL még a megfelelõ algoritmusokat is biztosítja, mint például a \verb|for_each|, a \verb'sort' vagy a \verb'find'. Az algoritmusok függvény-sablonként vannak implementálva, és iterátorokon keresztül kommunikálnak a konténerek\-kel. Ez volt az elsõ. Sokáig az egyetlen, hatékonyan használható generikus könyvtár implementáció.

Az STL megközelítésének számos elõnye van az \verb'Object'eket tároló kon\-ténerekkel szemben:
\begin{itemize}
	\item {\bfseries Típus biztonságos}: A fordító mindent elvégez helyettünk. Fordítási-idõben példányosítja a osztály- és függvény-sablonokat, a megfelelõ típus ellenõrzéseket elvégezve, ebbõl eredõen a hibalehetõségeket drasztikusan lecsökkentve.
	\item {\bfseries Hatékony}: Elkerüli a fölösleges, futás-idejû, dinamikus típus konverziókat. A sablonok segítségével a fordító mindent a fordítási-idõben kiszámol, leellenõriz és behelyettesít -- minden a fordításkor eldõl semmit sem hagy futás-idõre.
	\item {\bfseries Egyszerû bõvíteni és programozni}: Akár új algoritmusokkal, akár új konténerekkel egyszerûen bõvíthetjük a könyvtárat, csak a megfelelõ függvény-sablonokat vagy osztályokat és iterátorokat kell implementálni.
\end{itemize}
Az utóbbiból az is adódik, hogy ha van $m$ típusunk és $n$ mûveletünk, akkor az objektum orientált hozzáállással ellentétben, ahol minden típus minden (virtuális) metódusát, azaz $O(n\cdot m)$ függvényt, kell implementálni, generikus programozással elég csak $O(n+m)$ függvény implementációja, vagyis külön kell implementálnunk a típusokat (és iterátoraikat) és külön az algoritmusokat, egymástól teljesen függetlenül.

Ezeket az elõnyöket, az STL oly módon képes megvalósítani, hogy egyál\-talán nem megy a programozó rovására, vagyis nem kell bonyolultabb kódot írni, sõt kevesebbet, ami kevesebb hibát eredményez. A C++ sablonok, fordításkor manipulálják a kódot, és egy csomó rutin munkát elvégeznek a programozó helyett. Ebben az esetben, ahelyett, hogy mi írjuk meg külön-külön az \verb'IntVector't és a \verb'FloatVector't, a sablonok ezt automatikusan megteszik helyettünk, ugyanis lényegében ugyan azt a kódot kell megírni, csak más típussal.

Az STL megalkotásával le lettek fektetve a generikus programozás alapjai a C++-ban.
