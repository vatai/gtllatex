\section{Alkalmazás -- GTL Draw}
A GTL és ezzel a generikus programozás lehetõségeinek és korlátainak fel\-tárása céljából készült a \emph{GTL Draw} rajzoló program (egy korábbi munkám ami nagyprogramként lett bemutatva). A program a következõ funkciókat valósítja meg:
\begin{description}
	\item[Alakzatok rajzolása] Kör, sokszög és szabályos sokszögek rajzolása.
	\item[Alakzatok módosítása] A már megrajzolt alakzatok módosítása, vagyis az alakzatok eltolása, forgatása és tükrözése.
\end{description}

\subsection{Az implementáció lényegesebb pontjai}

A GTL és a generikus programozás vizsgálat érdekében, a GTL Draw implementációjának következõ pontjait érdemes megemlíteni:
\begin{enumerate}
	\item \verb"double" lebegõpontos típussal van példányosítva mind három GTL alakzat. Ezért a \verb"double"ra be van vezetve \verb"typedef"fel egy \verb"scalar" szinonima. További szinonimák vannak bevezetve a példányosított alakzatokra és a vektorokra amelyekben tárolódnak:
	\begin{verbatim}
	typedef double scalar;
	typedef gtl::vect<scalar> Vect;

	typedef gtl::circle<scalar>		Circle;
	typedef gtl::poly<scalar>		Poly;
	typedef gtl::reg_poly<scalar>	RegPoly;

	typedef std::vector<Circle>		vCircle;
	typedef std::vector<Poly>		vPoly;
	typedef std::vector<RegPoly>	vRegPoly;
	\end{verbatim}
	\item A rajzlap tartalmát három vektor tárolja. Sorra \verb"vCircle", \verb"vPoly" és \verb"vRegPoly" típusú \verb"m_vCircle", \verb"m_vPoly" és \verb"m_vRegPoly" vektor tárolja a megfelelõ alakzatot.
	\item A program hat lényegesebb állapotban lehet: három állapot jellemzi a három alakzat rajzolását, három másik állapot pedig a három transzformáció végrehajtását.
	\item A program lekezel minden eseményt. Ezek közül a kattintás a rajzlapra a legösszetettebb. Az állapot függvényében, a következõ történik: 
	\begin{itemize}
	\item Ha alakzatot rajzolunk, akkor a megfelelõ vektor bõvül egy alakzattal.
	\item Ha transzformációs mûveletet hajtunk végre, akkor elõször végig\-keresi a program mind három vektort, hogy volt-e találat (alakzatra kattintottunk-e). Ha volt találat akkor az alakzat címét, amelyre rá lett kattintva, a \verb"Circle* pc", \verb"Poly* pp" és \verb"RegPoly*" \verb"rp" mutató közül, a megfelelõben tárolja és a másik kettõt nullára állítja. Majd mind a három mutatóra (pontosabban a mutató által mutatott alakzatra) meghívódik a megfelelõ algoritmus, feltéve, hogy a mutató nem nulla.
	\end{itemize}
	\item Amikor szükség volt rá, három \verb"Draw" sablon-függvény hívással kirajzolódtak a három vektorban tárolt alakzatok.
\end{enumerate}

A program implementációjának részletes leírása megtalálható az \cite{gtldraw} cím\-en, a \emph{doc} könyvtár alatt. 

{\bfseries Fontos megszorítás}, hogy a GTL Draw program megírásakor, a generikus programozás tanulmányozása érdekében, abszolút kikötés volt, kizáróla\-gosan sablonok, illetve sablon könyvtár használata. Azt tapasztaltam, a program írása során, hogy a (szigorúan) generikus programozás, ezen megszorítások és kikötések mellet, nem teljesen alkalmas egy ilyen rajzprogram megírásához. A generikus könyvtár nagyon nagy erõvel bír és óriási lehetõség rejlik benne, de dinamikus polimorfizmus nélkül komoly gondot okoz a különbözõ típusú alakzatok (konténerek) tárolása, ugyanis nem lehet õket egy közös konténerbe tenni. Megpróbálhatjuk elemezni a GTL Draw-ban alkalmazott generikus programozás elõnyeit, de ez elég ambivalens és vitatható eredményekhez vezet.

\subsection{Elõnyök}
A generikus programozás egy olyan programozási paradigma, mely meta-programozásra épül, azaz fordítás idejû programozásra. Egy jól megírt meta-program vagy generikus sablon könyvtár, kiszámolja és el intézi a programozó helyett azt, ami eldönthetõ és kiszámítható fordítási-idõben. A generikus programozásnak általános elõnyei:
\begin{itemize}
	\item Típus biztonság
	\item Hatékonyság
	\item Egyszerû kód
\end{itemize}

\subsubsection{Típus biztonság}
A típus biztonság egyértelmûen teljesül. Sehol sem nincs a programban semmiféle típuskonverzió, minden objektumnak jól definiált típusa van. Ez\-ekkel a típusokkal megfelelõen példányosítódnak a megfelelõ függvény sablonok. Ha nem jó típusú objektumot adunk át, akkor azt a fordító rögtön jelzi, és a program nem fordul le. 

Ez alól egy apró kivétel a mutatók használata, de azok csak lokális válto\-zóként szerepeltek és könnyû belegondolni hogyan lehet megkerülni a mutatók használatát. Viszont még így is csak az okozhatott futás-idejû hibát, ha a null mutatóra hívjuk meg az algoritmust, de ezt könnyen ki lehet kerülni.

\subsubsection{Hatékonyság}
A hatékonyság abból adódik, hogy teljes mértékben el vannak kerülve az öröklõ\-dés, a virtuális függvények és a típus konverziók. A fordító program, például az alakzatok kirajzolásakor, fordítás-idõben létrehozza a megfelelõ kódot, ami futás idõben lefut. 

Attól függetlenül, hogy nincsenek ``rejtett'' konverziók és ``rejtett'' virtuá\-lis függvények (azaz függvény hívások) a programban, és a program pontosan azt fogja csinálni ami le van kódolva, csak ``bõvebben kifejtve'', látszik, hogy pár dolog talán ront egy picit a teljesítményen. Itt újra fel lehet hozni a mutatókat, és a null mutató vizsgálatát.

\subsubsection{Egyszerûbb kód}
Ez a legvitathatóbb ``elõny'', ugyanis az \emph{egyetlen} rajzlap tartalmát \emph{három} különbözõ vektorban kell tárolni, nem igazán mondható elegáns és egyszerû megoldásnak. Ez annak a következménye, hogy teljes mértékben mellõztük az öröklõdést és nincs egy õsosztályunk, ami tudna kör, sokszög és szabályos sokszög is lenni, és ilyen típusú vektorban vagy listában tárolhatnánk a rajzlap tartalmát. Ezért minden mûveletet, mint például a kirajzolás, a ``találat keresés'' (annak az alakzatnak a keresése, amelyre rákattintottunk), háromszor kell végrehajtani, különbözõ paraméterrel, a mutatós komplikáció\-kat nem is említve.

Azt viszont meg kell jegyezni igaz, hogy háromszor kellet meghívni például a \verb"Draw" függvényt, de csak egyszer kellet megírni és mindhárom alakzatra mûködött. Pontosabban kettõ \verb"Draw" függvény lett implementálva, ugyanis a kört, egy specializált \verb"Draw" függvény sablon rajzolta ki. Ezt is talán hatéko\-nyabb kódolásnak lehet tekinteni, mivel lehetõséget nyújtott, a megjelenítõ keretrendszer kör-rajzoló függvény alkalmazására, de ugyanakkor, az általá\-nos \verb"Draw" függvény sablon is ki rajzolta volna a kört\footnote{Az iterátor finomságán tudunk állítani, ha az input iterátor lekérdezõ függvényt egy paraméterrel látjuk el. Elég nagy finomság mellet, elvileg azonos eredményt érünk el.}, csak kevésbé hatékony\-an.

\subsection{Hátrányok}
Ahogy már korábban is említettük, a fõ hátrány az, hogy a sablonok által generált osztályok teljesen függetlenek egymástól. Nincs közös õsosztályuk, és ezért nem lehet egyszerre, úgymond ``egy kalap alatt'' kezelni õket. Hiányzik az a lehetõség, hogy például egy \verb"list<Shape*>" listában tároljuk õket. Ez ahhoz vezet, hogy a három különbözõ típushoz, három különbözõ változóra van szükség. 

A program írásának legkényelmetlenebb része volt a kiválasztott alakzat elmentése, ugyanis nem volt elég csak azt elmenteni, hányadik alakzat a tömbben, hanem azt is ki kell valahogyan találni, hogy melyik tömbben. Ezt persze csak úgy lehet, hogy mind a három tömböt végig kell nézni elõtte, miután a három mutató közül kell kiválasztani azt, hogy melyik az érvényes. 

\subsection{A polimorfizmus megkerülhetetlensége}
Az a kérdés merülhet fel bennünk, sõt fel is kell, hogy merüljön: \emph{Meg lehet-e ezt a problémát oldani generikus programozással, vagyis sablon meta-progra\-mozással?} A válasz erre egyáltalán nem triviális és azt fogjuk belátni, hogy a válasz erre a kérdésre nemleges.

\subsubsection{Generikus programozás egy definíciója}
David R. Musser, a generikus programozás egyik úttörõje, a honlapján azt írja a generikus programozás definíciójáról, hogy az: ``programming with concepts'', azaz programozás conceptekkel. Az angol concept, illetve a conception szó jelentése magyarul: fogalom, elgondolás, elképzelés, eszme, felfogás. Viszont a concept szónak egy új értelmezése is született a közelmúltban. Concept fogalmát nemrég vezeték be a C++-ba. Még hivatalosan a concept ellenõrzés nem része a szabványnak de hamarosan az lesz.

A concept a sablonoknál olyasmi, mint az interfész az öröklõdésnél. Ha adott egy sablon, melynek van egy nem specializált \verb"T" típus paramétre, akkor concept-ekkel lehet meghatározni azt, hogy szemantikailag és szintaktikailag mit várunk el a \verb"T" típus helyén példányosítandó típustól. 

Például az iterátoroktól elvárjuk, hogy lehessen léptetni (\verb"operator++"), lehessen az értékét lekérdezni (\verb"operator*") és lehessen egyenlõséget illetve egyenlõtlenséget vizsgálni (\verb"operator==" és \verb"operator!="). Ezeknek a pontos meghatározása az algoritmusok alkalmazásánál nagyon hasznos lenne, ugyanis a C++ mai eszközei, nem teszik lehetõvé, hogy egy nem általunk írt könyvtár generikus algoritmus paramétereirõl bármit tudjunk. Ha egy egyszerû függvényt hívunk meg, a szignatúrája mindent elmond a paraméterei\-rõl, míg egy sablon deklaráció csak azt árulja el, hogy hány különbözõ paraméter\-rel lehet példányosítani, és hogy ezek közül melyik egy típusnév és melyik egy bizonyos meghatározott típusú értékek. A concept-ek specifikálnák, hogy egy típusnak, amellyel egy sablont szeretnénk példányosítani, milyen metódusokat, altí\-pusokat és \verb"typedef"eket kell tartalmazniuk.

A generikus programozás ereje, abban rejlik, hogy ha az adatszerkezeteinket ``hasonlóan'' írjuk meg, vagyis úgy, hogy megfeleljenek bizonyos concept-eknek, akkor könnyû ezekre az adatszerkezetekre olyan algoritmusokat írni, melyek függvény-sablonokként vannak implementálva. A generikus programozással megvalósított algoritmusok, szintaktikailag lényegében azonos kódot generálnak, melyek csak a paraméterként átadott típusban különböznek. Ebbõl adódóan, a fordító program, legenerálja nekünk azt a kódot amire nekünk szükségünk van, de a döntéseket nem halaszthatjuk el futás-idõre. A sablonok kizárólag fordítási idõben játszanak szerepet. 

Ezért van az, hogy a generikus programozás fõ alkalmazási területe a könyvtárak fejlesztése mivel ott a leghatékonyabb. Konkrét program írásá\-nál, nem nagyon fogunk generikus programozást használni, ugyanis ott már in\-kább a generikus programozás gyümölcseit (a generikus könyvtárakat) fogjuk hasz\-nálni. Egy programozó nem fog csakis azért iterátorokat implementálni és meta-programokat írni, hogy egy konkrét feladathoz, egy konkrét problémát megoldjon. A generikus programozás csakis akkor kifizetõdõ stra\-tégia, ha nagymértékben újrahasználható, hatékony kódot szeretnénk létre\-hozni. Talán úgy lehetne, a generikus programozásra gondolni, mint az objektum orientált programozás megfelelõjére, azzal a különbségekkel, hogy a generikus programozás könyvtárak fejlesztésére alkalmasabb mivel a fordításig halasztja a döntéseket, hogy a könyvtár felhasználja az alkalmazás írásakor dönthesse el hogyan valósítja meg a programot, míg az objektum orientált programozás alkalmazások fejlesztésére alkalmasabb mivel futás-idõre halasztja el a döntéseket, hogy az alkalmazás felhasználja, futás-idõben mondja meg, mit csináljon a program.

\subsubsection{GTL kontra STL}
Elsõ ránézésre a GTL-t nem nehéz megírni az STL analógiájára, viszont ha jobban szemügyre vesszük, akkor lényeges különbségeket fedezhetünk fel a két könyvtár között. Az analógia szembetûnõ és nagyon egyszerû: 
\begin{itemize}
	\item A GTL alakzatai, az STL konténereinek felelnek meg.
	\item A GTL algoritmusai az alakzatokra vannak megírva, míg az STL algoritmusai a konténerekre.
	% \item A GTL algoritmusai grafikus jellegûek, míg az STL algoritmusai álta\-lános célú adat manipulációra szolgálnak.
\end{itemize}

Viszont ha belenézünk a GTL forrásába, akkor az elsõ szembetûnõ dolog a \verb"vect<T>" osztály sablon. Mivel síkbeli alakzatokat szeretnénk ábrázolni és az alakzatokat a jellegzetes pontjaikkal határozhatjuk meg (csúcsok, közép\-pont), ezért szükség van a pont definíciójára, amit egy valamilyen számtest feletti 2 dimenziós\footnote{Természetesen nem lenne nehéz megvalósítani az $n$ dimenziós, általános esetet.} vektortér eleme ábrázol. Továbbá a \verb"vect<T>" \verb"rotate" metódusában megfigyelhetõ, hogy a \verb"T" egy olyan numerikus típus kell, hogy legye, amely \verb"double"ra konvertálható. 

A GTL úgy van elképzelve, hogy az alakzatok olyan konténerek amelyek pontokat tárolnak. Tehát attól függetlenül, hogy paraméterezhetõ osztály-sablonként vannak implementálva, a paraméter nem fogja meghatározni mit fog tárolni, ugyanis mindig pontokat tárol, sõt \verb"double"ra konvertálható \verb"T" típussal példányosított \verb"vect<T>" vektorokat (vagyis autóbusz típussal nem valószínû, hogy sikerül példányosítani sem az alakzatokat, de még a vektorokat sem). Ez feltûnõen elüt az STL sokoldalúságától és flexibilitásától, mivel az STL konténerei bármilyen típusú objektumokat tárolhatnak.

A szakértõk szerint, az objektum orientált paradigmát akkor érdemes alkalmazni, amikor az objektumoknak hasonló a struktúrájuk, míg a generikus paradigmát akkor amikor hasonló a viselkedésük. Az alakzatokra egy kissé mindkettõ igaz, vagyis egyik sem. Hasonló a struktúrájuk, mivel mindegyik alakzat, valamilyen módon pontokat tárol, viszont különbözik is a struktúrájuk, mivel a kör csak a középpontot és a sugarat tárolja tárolja, a szabályos sokszög a középpontot, az egyik csúcsot és a csúcsok számát, míg az általános sokszög az összes csúcsot egy vektorban tárolja, mégis mind három alakzat iterátora \verb"vect<T>" típusú értékre mutat. A viselkedésük is hasonlónak vélhetõ, ugyanis ciklikusak, letudjuk kérdezni az egyik csúcsot, de ugyan akkor különbségeket is felfedezhetünk, mint például az, hogy a sokszögnek és a szabályos sokszögnek lekérdezhetjük a méretét (\verb"size()"), míg a körnél ez a mûvelet nem értelmes, ugyanígy a sokszöghöz adhatunk hozzá új csúcsokat és törölhetünk is belõle, ugyanakkor a másik kettõ ezeket a mûveleteket nem támogatja. Ez is azt indokolja, hogy az alakzatokat nem célszerû teljesen és szigorúan generikus programozással megvalósítani.

Ezzel szemben az STL az alap típusok azonos viselkedésére és a mutatók viselkedésére támaszkodik. Az STL olyan konténereket és algoritmusokat valósít meg, amelyek olyan alapvetõ mûveleteket követelnek meg a példányosítandó típusoktól, mint például az alapértelmezett konstruktor, értékadás operátor, egyenlõség vizsgálat operá\-tor, vagy az iterátoroknál az inkrementállás, a dereferenciálhatóság, két iterá\-tor különbsége stb. Ezeket a beépített típusok és mutatók mind teljesítik, ahogy az STL adatszerkezetei és iterátorai is. Ebbõl adódik a fordítás-idejû polimorfizmus, és ezért viselkednek úgy az STL típusai mintha beépített típusok lennének, vagyis ezért gondolhatunk az STL-re mint a nyelv bõvítésére. A GTL polimorfizmusát viszont inkább csak az biztosítja, hogy az iterátorok mindig egy \verb"vect<T>"-re mutatnak.

Végül a legszembetûnõbb különbség az STL és a GTL között az, hogy melyik hol használja ki a polimorfizmust. Az STL abban jeleskedik, hogy egyik konténert kicserélhetjük a másikra, és egy újrafordítás után, nagy valószínûséggel minden tökéletesen fog mûködni. Viszont ez program tervezési döntés segítése, vagyis alkalmazása. Ha például egy vektor helyet egy listában szeretnénk tárolni az adatainkat, akkor ezt a program tervezéskor fogjuk megváltoztatni. Nem fogunk egy olyan programot írni, amely futás idõben változtatja meg a belsõ reprezentációját, a GTL Draw-ban pedig pontosan ez történik: például az eltolásnál (vagy más transzformáció alkalmazásánál) attól függõen, hogy milyen alakzatra kattintottunk, attól függõen fog a \verb"move" függvény-sablon példányosításai közül az egyik meghívódni. 

Itt láthatunk még egy nagy különbséget a két könyvtár között. Míg egy, az STL könyvtárat használó, programban a fordító csak azokat az függvény-sablonokat (algoritmusokat) csak azokkal a osztály-sablonokkal (konténerek\-kel) példányosítja, amelyeket a programozó a tervezés folyamán hasznosnak talált. A GTL Drawban és valószínûleg ez más GTL-re épülõ rajzoló programokra is igaz lenne, hogy a fordítónak példányosítania kell majd a tervezés során használt összes függvény-sablont (transzformációt) az összes osztály-sablonnal (alakzattal). Tehát ha a programunkban van egy listánk és egy vektorunk, és a listában keresni kell a vektort meg rendezni kell, akkor a \verb"find" csak a listával példányosul, a \verb"sort" meg csak a vektorral, míg nem valószínû, hogy egy rajzolóprogramot úgy szeretnénk megírni, hogy csak háromszögeket tudjon forgatni és csak poligonokat eltolni. Ezért a GTL Draw fordításako, minden függvény-sablont minden osztály-sablonnal példányosul még ha nem is fog lefutni a program futtatása kor.

\subsubsection{Összetett alakzat}
Egy alapvetõ hiányossága a GTL-nek az összetett alakzat (\verb"composite"), ami lényegében megoldaná a fejlesztés alatt felmerülõ összes problémát. Az összetett alakzat alatt egy olyan típust értünk, amelyik több fajta alakzatból áll és lehetõvé teszi, hogy ezeken az alakzatokon végigiteráljunk. Elsõ nekifutásban, azt gondolja az ember, hogy nem is olyan nagy probléma: létreho\-zunk egy \verb"composite<T>" osztály-sablont, ami egy listában tárolja az alakzatokat. De mivel nincs közös bázisosztályunk, ezért nem tudjuk egy listába rakni a különbözõ típusú alakzatainkat.

Az összetett alakzat problémája körülbelül egyenértékû az eredeti problé\-mánkkal, a polimorfizmus hiányával. Majd látni fogjuk, hogy kicsit finomít\-unk a problémán és közelebb jutunk egy kompromisszumos megoldáshoz.

Az alakzatok kirajzolása szempontjából teljesen mindegy, hogy a polimorfizmust sikerül-e megkerülni vagy egy összetett típust tudunk megvalósítani. Ha valahogy sikerülne megkerülni a polimorfizmust és sikerülne egy konténerbe helyezni az összes alakzatot, akkor egy ilyen konténerrel a \verb"composite"ban is tudnánk tárolni az objektumokat. Másrészt ha létre tudunk hozni egy összetett alakzatot, amely tetszõleges alap alakzatokat tartalmaz, akkor egy nagy összetett alakzat típusú objektumban tudjuk tárolni az egész rajzlap tartalmát is, és azt kell kirajzolni.

Ha jobban belegondolunk, ez egyrészt nem valósítható meg valamilyen öröklõdés nélkül vagy típuskonverzió nélkül (dinamikus polimorfizmus) más\-részt ha még sikerülne is kikerülni a polimorfizmust és a típuskonvertálgatáso\-kat, akkor is homály az, hogy milyen iterátorokkal fogunk dolgozni, de errõl majd késõbb. 

Vizsgáljuk meg elõtte a keresés (vagyis ``találat'' keresés, annak megálla\-pítása, hogy melyik alakzatra kattintottunk) szempontjából a két problémát. Egyrészt a polimorfizmus szigorúbbnak tûnhet, ugyanis ha megengedjük a dinamikus polimorfizmust, például öröklõdéssel, akkor tudunk csinálni alakzatra mutató mutatót és ebben tárolhatjuk azt az alakzatot a amelyre rá\-kattintottunk. Viszont az ha csak összetett alakzatunk van, és például ebben tároljuk a rajzlap tartalmát, akkor az szigorított feltétel, hogy le tudjuk menteni, az összetett alakzat egyik alkotó elemét. 

\subsubsection{Iterátor konkatenáció}
Már volt rá utalva, hogy lényegében nem is az alakzatokat kellene összefûzni hanem az iterátorokat. Az összetett alakzat kirajzolásánál is egy alapvetõ problémába ütközünk: hogyan fogjuk végig iterálni az alakzatokat. Egyrészt, hogyan fogjuk tudni, hogy egy alakzat végére értünk, másrészt milyen típusú iterátorral fogunk iterálni, ugyanis a különbözõ konténerek iterátorai, külön\-bözõ típusúak, meg ha teljesen azonos is a szemantikájuk. A teljesen azonos szemantika pedig teljesül: feltéve, hogy azonos \verb"scalar" típussal példányosí\-tottuk az alakzatainkat, akkor világos, hogy mindhárom alakzat iterátora egy-egy \verb"vect<scalar>" típusú pontra mutat és ha léptetjük akkor körbejárja az alakzat csúcsait.

Újra felmerül a kérdés, hogy objektum orientált vagy generikus megoldást kellene alkalmazni. Az öröklõdés újra kézenfekvõ megoldás. Az iterátoroknak lenne egy közös bázis iterátor osztálya, virtuális metódusokkal, az alakzatok helyet az iterátorokat kellene csak tárolni, például az egyik tömbben az input iterátorokat, a másik tömbben az output iterátorokat\footnote{Valójában célszerûbb lenne iterátor párokat tárolni, de ettõl most eltekintünk.}. Legyen például a következõ a felépítés:
\begin{verbatim}
  template<typename T> struct 
  input_iterator_base { 
    typedef vect<T> value_type;
    typedef input_iterator_base iterator;
    // ...
    virtual value_type operator*();
    virtual iterator& operator++();
  };
  // output_iterator_base hasonlóan

  template<typename T> struct poly {
    struct input_iterator  : input_iterator_base<T> ;
    struct output_iterator : output_iterator_base<T> ;
    // ...
  };
  // reg_poly és circle hasonlóan
  
\end{verbatim}
Így bevezethetnénk az következõ változókat:
\begin{verbatim}
  class CGTLDrawDoc {
    list<input_iterator_base<scalar>*>  input_iterators;
    list<output_iterátor_base<scalar>*> output_iterators;
    // ...
  }
\end{verbatim}
De így már felesleges az algoritmusainkat függvény-sablonként implementál\-ni, ugyanis azt, hogy melyik paraméter \verb"input_iterator_base*" és melyik \verb"output_iterator_base*" típusú azt meg tudjuk már a program írásakor mondani. Így például a kirajzoló függvény lehetne a következõ\footnote{Természetesen lehetne általánosabban, függvény-sablonként megvalósítani, de most erre nincs szükség.}:
\begin{verbatim}
  void Draw( list<input_iterator_base<scalar> >& l, 
    Graphics& g, 
    Pen& p )
  {
    list<input_iterator_base<scalar> >::iterator list_iter;
    input_iterator_base iterator save, iter;
    Point p1, p2;

    for(list_iter=l.begin(); list_iter!=l.end; list_iter++)
    {
      save = iter = *list_iter;
      p1 = p2 = ToPoint( *iter );

      do {
        iter++;
        p2 = ToPoint( *iter );
        g.DrawLine(&p, p1, p2);
        p1 = p2;
      } while(iter!=save);
     }
   }
\end{verbatim}

Ez már egy kompromisszumos megoldás, de túlzottan, sõt szinte kizárólag az öröklõdésre és az objektum orientált programozásra támaszkodik. Egyér\-telmû ennek a megközelítésnek a hátránya, mivel a iterátor léptetésnél és a \verb"*" operá\-tornál virtuális függvény hívás történik és ezek az alapvetõ mûveletek minden ciklusmagban meghívódnak. 

Sablonokkal viszont nem lehet megoldani, kivéve ha nem szimuláljuk valahogy a polimorfizmus, például \verb"void*"-ra konvertálva és megfelelõ meta-programozással biztosítva, hogy mindig a megfelelõ függvény hívódjon meg. Egy ilyen jellegû megoldás lehetne a következõ: 
\begin{verbatim}
  template<typename T> stuct node {
    poly<T>::input_iterator* poly_input_iter;
    poly<T>::output_iterator* poly_output_iter;
    // többi alakzatra hasonlóan
    node* next;
  }
\end{verbatim}
De ez nagyon csúnya megoldás lenne, mert igaz, hogy a tárolást megoldaná, és csak ezt a struktúrát kellene módosítani új típusú alakzat hozzáadásakor, de a \verb"node" kiolvasása okozna gondot, azaz egy bonyolult \verb"if/else" elágazáshoz vezetne, ami a polimorf szerû viselkedést biztosítaná. Ez talán megkerülhetõ lenne meta-programozással, a \emph{Boost.Function}hoz hasonló megol\-dással.

\subsubsection{Konkluzió}
Végül gondoljuk át, általánosan, hogy mit is követelünk meg a GTL grafikus könyvtártól. Elsõ sorban azt várjuk el, hogy az alakzatokat hatékonyan ábrázolja és hogy ezekhez az alakzatokhoz biztosítson megfelelõ transzfor\-mációkat és algoritmusokat, másrészt legyen könnyen bõvíthetõ az alakzatok készlete és az algoritmusok készlete is. Ezeket lényegében teljesíti is a GTL. 

Ami hiányzik belõle, az a lehetõség, hogy az alakzatokat közös konténerbe lehessen helyezni és ezt fordítás-idejû, statikus polimorfizmussal, amit a generikus programozás nyújt, nem lehet megoldani. Tegyük fel, ugyanis, hogy van egy olyan ``ügyes konténerünk'', ami el tudná tárolni az alakzatokat és statikus polimorfizmusra támaszkodik. Ez azt jelentené, hogy fordítás-idõben el tudja dönteni, hogy milyen alakzattal fog bõvülni. Ez viszont egy rajzoló programban megengedhetetlen, ugyanis a rajzoló programban, a felhasználó csak futás-idõben fogja megadni, hogy milyen alakzatokat fog rajzolni. Elég csak az elsõ elemét megfigyelni ennek az ``ügyes konténernek'', még ha valahogy, el is tudja tárolni az alakzatot, és vissza is tudja adni, akkor is egy \verb"if" elágazással le kell kezelni külön-külön mindegyik alakzat esetét, mivel az volt a feltevés, hogy az alakzatok csak statikusan polimorfak és nincs közös bázisosztályuk.

Ha belegondolunk, világos, hogy dinamikus polimorfizmusra van szüksé\-günk. Az öröklõdés és a virtuális függvények pontosan azt a problémát oldják meg amivel szembesülünk. A virtuális függvények, abból a célból tervezték, hogy ha egy objektum típusának és viselkedésének mivoltát, el akarjuk halasztani futási-idõre, akkor ne kelljen bonyolult elágazás struktúrákat írni. 

Ennek a döntésnek az elhalasztásának ára van. Programozásban, mindig amikor késõbbre halasztunk egy döntés, azt valamivel kompenzálni kell. Ha csak futás idõben dõl el, hogy melyik függvény fog meghívódni, akkor azt vagy egy függvény mutatóban (virtuális függvény táblázat) vagy egy típus azonosítóban kell tárolni és utána konvertálni. A naiv programozó utópiája, hogy egy olyan programot készít amelyen csak egy nyomógomb van, és ha rákattint az ember, azt csinálja a program amit az ember kíván. Ez egy illúzió. Ha nem mindig ugyanazt a rajzot szeretném rajzolni, vagy nem egy véletlenszerûen generált rajzok akarok, hanem tényleg egy olyan rajzot amit én rajzoltam, akkor azt valahogy a program használatakor, futás-idõben kell a programnak kirajzolnia, nem tolható el a döntés fordítás-idõbe. Lehet, hogy csak köröket fogunk rajzolni, de a fordító ezt nem tudhatja és a sokszögeket kezelõ kódot is le kell, hogy fordítja és azokat az esetek is le kell, hogy legyenek kezelve benne, hogy mi van a ha sokszögre kattintunk és azt akarjuk elforgatni. Ezt meta-programozással nem tudjuk elérni, mivel a meta-programozás lényegében a fordító programból egy interpretert csinál (meta-program egy olyan program amely a fordítás-idõben fut le) és ennek a meta-programnak az eredményeit futtatás elõtt rögzíti.

