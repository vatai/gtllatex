\section{Alkalmazás -- GTL Draw}
A GTL és ezzel a generikus programozás lehetõségeinek és korlátainak fel\-tárása céljából készült a \emph{GTL Draw} rajzoló program (egy korábbi munkám ami nagyprogramként lett bemutatva). A program a következõ funkciókat valósítja meg:
\begin{description}
	\item[Alakzatok rajzolása] Kör, sokszög és szabályos sokszögek rajzolása
	\item[Alakzatok módosítása] A már megrajzolt alakzatok módosítása, vagyis az alakzatok eltolása, forgatása és tükrözése.
\end{description}

\subsection{Az implementáció lényegesebb pontjai}

A GTL és a generikus programozás vizsgálat érdekében, a GTL Draw implementációjának következõ pontjait érdemes megemlíteni:
\begin{enumerate}
	\item \verb"double" lebegõpontos típussal van példányosítva mind három GTL alakzat. Ezért a \verb"double"ra be van vezetve \verb"typedef"fel egy \verb"scalar" szinonima. További szinonimák vannak bevezetve a példányosított alakzatokra és a vektorokra amelyekben tárolódnak:
	\begin{verbatim}
	typedef double scalar;
	typedef gtl::vect<scalar> Vect;

	typedef gtl::circle<scalar>		Circle;
	typedef gtl::poly<scalar>		Poly;
	typedef gtl::reg_poly<scalar>	RegPoly;

	typedef std::vector<Circle>		vCircle;
	typedef std::vector<Poly>		vPoly;
	typedef std::vector<RegPoly>	vRegPoly;
	\end{verbatim}
	\item A rajzlap tartalmát három vektor tárolja. Sorra \verb"vCircle", \verb"vPoly" és \verb"vRegPoly" típusú \verb"m_vCircle", \verb"m_vPoly" és \verb"m_vRegPoly" vektorok tárolja a megfelelõ alakzatot.
	\item A program hat lényegesebb állapotban lehet: három állapot jellemzi a három alakzat rajzolását, három másik állapot pedig a három transzformáció végrehajtását.
	\item A program lekezel minden eseményt. Ezek közül a kattintás a rajzlapra a legösszetettebb, az állapot függvényében, a következõ történik: 
	\begin{itemize}
	\item Ha alakzatot rajzolunk, akkor a megfelelõ vektor bõvül egy alakzattal.
	\item Ha transzformációs mûveletet hajtunk végre, akkor elõször végig\-keresi a program mind három vektort, hogy volt-e találat (alakzatra kattintottunk-e). Ha találat volt akkor az alakzat címét, amelyre rá lett kattintva, a \verb"Circle* pc", \verb"Poly* pp" és \verb"RegPoly*" \verb"rp" mutató közül, a megfelelõben tárolja és a másik kettõt nullára állítja. Majd mind a három mutatóra (pontosabban a mutató által mutatott alakzatra) meghívódik a megfelelõ algoritmus feltéve, hogy a mutató nem nulla.
	\end{itemize}
	\item Amikor szükség volt rá, három \verb"Draw" sablon függvény hívással kirajzolódtak a három vektorban tárolt alakzatok.
\end{enumerate}

A programmal implementáció részletes leírása megtalálható az \cite{gtldraw} címen, a \emph{doc} könyvtár alatt. 

{\bfseries Fontos megszorítás} volt, hogy a GTL Draw program megírásakor, a generikus programozás tanulmányozása érdekében, abszolút kikötés volt, kizáróla\-gosan sablonok, illetve sablon könyvtár használata. Azt tapasztaltam, a program írása során, hogy a (szigorúan) generikus programozás, vagyis ezen megszorítások és kikötések mellet, nem teljesen alkalmas egy ilyen rajzprogram megírásához. A generikus könyvtár nagyon nagy erõvel bír és óriási lehetõség rejlik benne, de dinamikus polimorfizmus nélkül komoly gondot okoz a különbözõ típusú alakzatok (konténerek) tárolása, ugyanis nem lehet õket egy közös konténerbe tenni. Megpróbálhatjuk elemezni a GTL Draw-ban alkalmazott generikus programozás elõnyeit, de ez elég ambivalens és vitatható eredményekhez vezet.

\subsection{Elõnyök}
A generikus programozás egy olyan programozási paradigma, mely meta-programozásra épül, azaz fordítás idejû programozásra. Így amit el tudunk dönteni, ki tudunk szûrni fordítási idõben, azt egy jól megírt meta-program vagy generikus sablon könyvtár, el intézi nekünk, vagyis gondoskodik amirõl bír. A generikus programozásnak általános elõnyei:
\begin{itemize}
	\item Típus biztonság
	\item Hatékonyság
	\item Egyszerû kód
\end{itemize}

\subsubsection{Típus biztonság}
A típus biztonság egyértelmûen teljesül. Sehol se nincs a programban semmiféle típuskonverzió, minden objektumnak jól definiált típusa van. Ez\-eknek a típusokkal megfelelõen példányosítódnak a megfelelõ függvény sablonok. Ha nem jó típusú objektumot adunk át, akkor azt a fordító rögtön jelzi, és a program nem  fordul le. 

Ez alól egy apró kivétel a mutatók használata, de azok csak lokális válto\-zóként szerepeltek és könnyû belegondolni hogyan lehet megkerülni a mutatók használatát. Viszont még így is csak az okozhatott hibát futás idejû hibát ha a null mutatóra hívjuk meg az algoritmust, de ezt könnyen ki lehet kerülni.

\subsubsection{Hatékonyság}
A hatékonyság abból adódik, hogy teljes mértékben el van kerülve az öröklõ\-dés, a virtuális függvények és a típus konverziók. A fordító program, például az alakzatok kirajzolásakor, fordítás-idõben létrehozza a megfelelõ kódot, ami futás idõben lefut. 

Konkrét mérések nem voltak, részben azért is mert nem volt mihez. Attól függetlenül, hogy nincsenek, ``rejtett'' konverziók és ``rejtett'' virtuális függvények (azaz függvény hívások) a programban, és a program pontosan azt fogja csinálni amit le van kódolva, csak ``bõvebben kifejtve'', látszik, hogy pár dolog talán ront egy picit a teljesítményen. Itt újra fel lehet hozni a mutatókat, és a null mutató vizsgálatát.

\subsubsection{Egyszerûbb kód}
Ez a legvitathatóbb ``elõny'', ugyanis mivel az egyetlen rajzlap tartalmát három különbözõ vektorban kell tárolni, nem igazán mondható elegáns és egyszerû megoldásnak. Ez annak a következménye, hogy teljes mértékben mellõztük az öröklõdést és nincs egy õsosztályunk, ami tudna kör is, sokszög is és szabályos sokszög is lenni, és ilyen típusú vektorban vagy listában tárolhatnánk a rajzlap tartalmát. Ezért minden mûveletet, mint például a kirajzolás, a ``találat keresés'' (annak az alakzatnak a keresése, amelyre rákattintottunk), háromszor kell végrehajtani, különbözõ paraméterrel. A mutatós komplikációkat nem is említve.

Az viszont meg kell jegyezni, hogy igaz, hogy háromszor kellet meghívni, például a \verb"Draw" függvényt, de csak egyszer kellet megírni és mindhárom alakzatra mûködött. Pontosabban kettõ \verb"Draw" függvény lett implementálva, ugyanis a kört, egy specializált \verb"Draw" függvény sablon rajzolta ki. Ezt is talán a hatékonyabb kódolásnak lehet tekinteni, mivel lehetõséget nyújtott, a megjelenítõ keretrendszer kör-rajzoló függvény alkalmazására, de ugyanakkor, az általános \verb"Draw" függvény sablon is ki rajzolta volna a kört\footnote{Az iterátor finomságán tudunk állítani, ha az input iterátor lekérdezõ függvényt egy paraméterrel látjuk el. Elég nagy finomság mellet, elvileg azonos eredményt érünk el.}, csak lassabban.

\subsection{Hátrányok}
Ahogy már korábban is meg lett említve, a fõ hátrány az, hogy a sablonok által generált osztályok teljesen függetlenek egymástól. Nincs közös õsosztályuk, és ezért nem lehet egyszerre, úgymond ``egy kalap alatt'' kezelni õket. Hiányzik az a lehetõség, hogy például egy \verb"list<Shape*>" listában tároljuk õket. Ez ahhoz vezet, hogy a három különbözõ típushoz, három különbözõ változóra van szükség. 

A program írásának legkényelmetlenebb része volt a kiválasztott alakzat elmentése. Ugyanis nem volt elég csak azt elmenteni, hányadik alakzat a tömbben, hanem azt is ki kell valahogy találni, hogy melyik tömbben. Ezt persze csak úgy lehet, hogy mind a három tömböt végig kell nézni elõtte. Utána meg három mutató közül kell kiválasztani azt, hogy melyik az érvényes. 

\subsection{A polimorfizmus megkerülhetetlensége}
Az a kérdés merülhet fel bennünk, sõt fel is kell, hogy merüljön: \emph{Meg lehet-e ezt a problémát oldani generikus programozással, vagyis sablon meta-progra\-mozással?} A válasz erre egyáltalán nem triviális és azt fogjuk belátni, hogy a válasz erre a kérdésre nemleges.

\subsubsection{Generikus programozás egy definíciója}
David R. Musser, a generikus programozás egyik úttörõje, a honlapján azt írja a generikus programozás definíciójáról, hogy az: ``programming with concepts'', azaz programozás conceptekkel. Az angol concept, illetve a conception szó jelentése magyarul: fogalom, elgondolás, elképzelés, eszme, felfogás. Viszont a concept szónak egy új értelmezése is született a közelmúltban. Concept fogalmát nemrég vezeték be a C++-ba. Még hivatalosan a concept ellenõrzés nem része a szabványnak de hamarosan az lesz.

A concept a sablonoknál olyasmi, mint az interfész az öröklõdésnél. Ha adott egy sablon, melynek egy van egy nem specializált \verb"T" típus változója, akkor concept-ekkel lehet meghatározni azt, hogy mit várunk el a \verb"T" típus helyén példányosítandó típustól. 

Például az iterátoroktól elvárjuk, hogy lehessen léptetni (\verb"operator++"), lehessen az értékét lekérdezni (\verb"operator++") és lehessen egyenlõséget illetve egyenlõtlenséget vizsgálni (\verb"operator==" és \verb"operator!="). Ezeknek a pontos meghatározása az algoritmusok alkalmazásánál nagyon hasznos lenne, ugyanis a C++ mai eszközei, nem teszik lehetõvé, hogy egy nem általunk írt könyvtár generikus algoritmus paramétereirõl bármit tudjunk. Ha egy egyszerû függvényt hívunk meg, a szignatúrája mindent elmond a paraméterei\-rõl, míg egy sablon deklaráció csak azt árulja el, hogy hány különbözõ paraméter\-rel lehet példányosítani, és hogy ezek közül melyik egy típusnév és melyik egy bizonyos meghatározott típusú értékek. A concept-ek specifikálnák, hogy egy objektum típusának, amellyel egy sablont szeretnénk példányosítani, milyen metódusokat kell, hogy implementáljon és milyen altí\-pusokat és \verb"typedef"eket kell hogy tartalmazzon.

A generikus programozás ereje, abban rejlik, hogy ha az adatszerkezeteinket ``hasonlóan'' írjuk meg, vagyis úgy, hogy megfeleljenek bizonyos concept-eknek, akkor könnyû ezekre az adatszerkezetekre olyan algoritmusokat írni, melyek függvénysablonokként vannak implementálva. A generikus programozással megvalósított algoritmusok, szintaktikailag lényegében azonosak, csak a paraméterek típusában különböznek. Ebbõl adódóan, a fordító program, legenerálja nekünk azt a kódot amire nekünk szükségünk van, de a döntéseket nem halaszthatjuk el futás-idõre. A sablonok kizárólag fordítási idõben játszanak szerepet. 

Ezért van az, hogy a generikus programozás fõ alkalmazási területe a könyvtárak fejlesztése mivel ott a leghatékonyabb. Konkrét program írásá\-nál, nem nagyon fogunk generikus programozást használni, ugyanis ott már in\-kább a generikus programozás gyümölcseit (a generikus könyvtárakat) fogjuk hasz\-nálni. Egy programozó nem fog csakis azért iterátorokat implementálni és meta-programokat írni, hogy egy konkrét feladathoz, egy konkrét problémát megoldjon. A generikus programozás csakis akkor kifizetõdõ stra\-tégia, ha nagymértékben újrahasználható, hatékony kódot szeretnénk létre\-hozni. Talán úgy lehetne, a generikus programozásra gondolni, mint az objektum orientált programozás megfelelõjére, azzal a különbségekkel, hogy a generikus programozás könyvtárak fejlesztésére alkalmasabb mivel a fordításig halasztja a döntéseket, hogy a könyvtár felhasználja az alkalmazás írásakor dönthesse el hogyan valósítja meg a programot, míg az objektum orientált programozás alkalmazások fejlesztésére alkalmasabb mivel futás-idõre halasztja el a döntéseket, hogy az alkalmazás felhasználja, futás-idõben mondja meg, mit csináljon a program.

\subsubsection{GTL kontra STL}
Elsõ ránézésre a GTL-t nem nehéz megírni az STL analógiájára, viszont ha jobban szemügyre vesszük, akkor lényeges különbségeket fedezhetünk fel a két könyvtár között. Az analógia szembetûnõ és nagyon egyszerû: 
\begin{itemize}
	\item A GTL alakzatai, az STL konténereinek felelnek meg.
	\item A GTL algoritmusai az alakzatokra vannak megírva, míg az STL algoritmusai a konténerekre.
	%\item A GTL algoritmusai grafikus jellegûek, míg az STL algoritmusai álta\-lános célú adat manipulációra szolgálnak.
\end{itemize}

Viszont ha belenézünk a GTL forrásába, akkor az elsõ szembetûnõ dolog a \verb"vect<T>" osztály sablon. Mivel síkbeli alakzatokat szeretnénk ábrázolni és mivel az alakzatokat a jellegzetes pontjaikkal határozhatjuk meg (csúcsok, középpont), ezért szükség van a pont definíciójára, amit egy valamilyen számtest feletti 2 dimenziós \footnote{Természetesen nem lenne nehéz megvalósítani az $n$ dimenziós, általános esetet.} vektortér eleme ábrázol. Továbbá a \verb"vect<T>" \verb"rotate" metódusában megfigyelhetõ. hogy a \verb"T" egy olyan numerikus típus kell, hogy legye, amely \verb"double"ra konvertálható. 

A GTL úgy van elképzelve, hogy az alakzatok olyan konténerek amelyek pontokat tárolnak. Tehát attól függetlenül, hogy paraméterezhetõ osztály-sablonként vannak implementálva, a paraméter nem fogja meghatározni mit fog tárolni, ugyanis mindig pontokat tárol, sõt \verb"double"ra konvertálható \verb"T" típussal példányosított \verb"vect<T>" vektorokat. Ez feltûnõen elüt az STL sokoldalúságától és flexibilitásától, mivel az STL konténerei bármilyen típusú objektumokat tárolhatnak.

A szakértõk szerint, az objektum orientált paradigmát akkor érdemes alkalmazni, amikor az objektumoknak hasonló a struktúrájuk, míg a generikus paradigmát akkor amikor hasonló a viselkedésük. Az alakzatokra egy kissé mindkettõ igaz, vagyis egyik sem. Hasonló a struktúrájuk, mivel mindegyik alakzat, valamilyen módon pontokat tárol, viszont különbözik is a struktúrájuk, mivel a kör csak a középpontot és a sugarat tárolja tárolja, a szabályos sokszög a középpontot és az egyik csúcsot, míg az általános sokszög az összes csúcsot egy vektorban tárolja, mégis mind három alakzat iterátora \verb"vect<T>" típusú értékre ``mutat''. A viselkedésük is hasonlónak vélhetõ, ugyanis ciklikusak, letudjuk kérdezni az elsõ csúcsot, de ugyan akkor különbségeket is felfedezhetünk, mint például az, hogy a sokszögnek és a szabályos sokszögnek lekérdezhetjük a méretét (\verb"size()"), míg a körnél ez a mûvelet nem értelmes, ugyanígy a sokszöghöz adhatunk hozzá új csúcsokat és törölhetünk is belõle, ugyanakkor a másik kettõ ezeket a mûveleteket nem támogatja. Ez is azt indokolja, hogy az alakzatokat nem célszerû teljesen és szigorúan generikus programozással megvalósítani.

Ezzel szemben az STL az alap típusok azonos viselkedésére és a mutatók viselkedésére támaszkodik. Az STL olyan konténereket és algoritmusokat valósít meg, amelyek olyan alapvetõ mûveleteket követel meg, mint például az alapértelmezett konstruktor, értékadás operátor, egyenlõség vizsgálat operá\-tor, vagy az iterátoroknál az inkrementállás, a dereferenciálhatóság, két iterá\-tor különbsége. Ezeket az beépített típusok és mutatók mind teljesítik, és az STL adatszerkezetei és iterátorai is teljesítik. Ebbõl adódik a fordítás-idejû polimorfizmus, és ezért viselkednek úgy az STL típusai mintha beépített típusok lennének. A GTL polimorfizmusát viszont inkább csak az biztosítja, hogy az iterátorok mindig egy \verb"vect<T>"-re mutatnak.

Végül a legszembetûnõbb különbség az STL és a GTL között az, hogy melyik hol használja ki a polimorfizmust. Az STL abban jeleskedik, hogy egyik konténert kicserélhetünk a másikra, és egy újrafordítás után, nagy valószínûséggel minden tökéletesen fog mûködni. Viszont ez program tervezési döntés segítsége, vagyis alkalmazása. Ha például egy vektor helyet egy listában szeretnénk tárolni az adatainkat, akkor ezt a program tervezéskor fogjuk megváltoztatni. Nem fogunk egy olyan programot írni, amely futás idõben változtatja meg a belsõ reprezentációját. A GTL Draw-ban pedig pontosan ez történik: például az eltolásnál (vagy más transzformáció alkalmazásánál) attól függõen, hogy milyen alakzatra kattintottunk, attól függõen fog a \verb"move" függvény sablon példányosításai közül az egyik meghívódni. 

Itt láthatunk még egy nagy különbséget a két könyvtár között. Míg egy, az STL könyvtárat használó, programban a fordító csak azokat az függvény-sablonokat (algoritmusokat) csak azokkal a osztály-sablonokkal (konténerek\-kel) példányosítja, amelyeket a programozó a tervezés folyamán hasznosnak talált. A GTL Drawban és valószínûleg ez más GTL-re épülõ rajzoló programokra is igaz lenne, hogy a fordítónak példányosítania kell majd a tervezés során használt összes függvény-sablont (transzformációt) az összes osztály-sablonnal (alakzattal). Tehát ha a programunkban van egy listánk és egy vektorunk, és a listában keresni kell a vektort meg rendezni kell, akkor a \verb"find" csak a listával példányosul, a \verb"sort" meg csak a vektorral, míg nem valószínû, hogy egy rajzolóprogramot úgy szeretnénk megírni, hogy csak háromszögeket tudjon forgatni és csak poligonokat eltolni. Ezért a GTL Draw írásakor, minden függvény-sablont minden osztály-sablonnal meg kellet hívni.

\subsubsection{Összetett alakzat}
Egy alapvetõ hiányossága a GTL-nek az összetett alakzat (\verb"composite"), ami lényegében megoldaná a fejlesztés alatt felmerülõ összes problémát. Az összetett alakzat alatt egy olyan típust értünk, amelyik több fajta alakzatból áll, és lehetséges ezeken az alakzatokon végigiterálni. Elsõ nekifutásban, azt gondolja az ember, hogy nem is olyan nagy probléma: létrehozunk egy \verb"composite<T>" osztály-sablont, ami egy listában tárolja az alakzatainkat. De mivel nincs közös bázisosztályunk, ezért nem tudjuk egy listába rakni a különbözõ típusú alakzatainkat.

Az összetett alakzat problémája körülbelül egyenértékû az eredeti problé\-mánkkal, a polimorfizmus hiányával. Majd látni fogjuk, hogy kicsit finomít\-unk a problémán és közelebb jutunk egy kompromisszumos megoldáshoz.

Az alakzatok kirajzolása szempontjából teljesen mindegy, hogy polimorfizmus sikerül e megkerülni vagy az egy összetett objektumot tudunk megvalósítani. Ha valahogy sikerülne megkerülni a polimorfizmust és sikerülne egy konténerbe helyezni az összes alakzatot, akkor egy ilyen konténerrel a \verb"composite"ban is tudjuk tárolni az objektumokat. Másrészt ha létre tudunk hozni egy összetett alakzatot, amely tetszõleges alap alakzatokat tartalmaz, akkor egy nagy összetett alakzat típusú objektumban tudjuk tárolni a rajzlap tartalmát is, és azt kell kirajzolni.

Ha jobban belegondolunk, ez egyrészt nem valósítható meg valamilyen öröklõdés nélkül vagy típuskonverzió nélkül (dinamikus polimorfizmus) más\-részt ha még sikerülne is kikerülni a polimorfizmust és a típuskonvertálgatáso\-kat, akkor is homály az, hogy az milyen iterátorokkal fogunk dolgozni, de errõl majd késõbb. 

Vizsgáljuk meg elõtte a keresés (vagyis ``találat'' keresés, annak megálla\-pítása, hogy melyik alakzatra kattintottunk) szempontjából a két problémát. Egyrészt a polimorfizmus szigorúbbnak tûnhet, ugyanis ha megengedjük a dinamikus polimorfizmust, például öröklõdéssel, akkor tudunk csinálni alakzatra mutató mutatót és ebben tárolhatjuk azt az alakzatot a amelyre rá\-kattintottunk. Viszont az ha csak összetett alakzatunk van, és például ebben tároljuk a rajzlap tartalmát, akkor az még szigorított feltétel, hogy le tudjuk menteni, az összetett alakzat melyik alkotó elemét keressük. 

\subsubsection{Iterátor konkatenáció}
Már utalva volt rá, hogy lényegében nem is az alakzatokat kellene összefûzni hanem az iterátorokat. Az összetett alakzat kirajzolásánál is egy alapvetõ problémába ütközünk: hogyan fogjuk végig iterálni az alakzatot. Egyrészt, hogyan fogjuk tudni, hogy egy alakzat végére értünk, másrészt milyen típusú iterátorral fogunk iterálni, ugyanis a különbözõ konténerek iterátorai, külön\-bözõ típusúak, meg ha teljesen azonos is a szemantikájuk. A teljesen azonos szemantika pedig teljesül: feltéve, hogy azonos \verb"scalar" típussal példányosí\-tottuk az alakzatainkat, akkor világos, hogy mindhárom alakzat iterátora egy-egy \verb"vect<scalar>" típusú pontra mutat és ha léptetjük akkor körbejárja az alakzat csúcsait.

Újra felmerül a kérdés, hogy objektum orientált vagy generikus megoldást kellene alkalmazni. Az öröklõdés újra az kézenfekvõ megoldás. Az iterátoroknak lenne egy közös bázis iterátor osztálya, virtuális metódusokkal, az alakzatok helyet az iterátorokat kellene csak tárolni, például az egyik tömbben az input iterátorokat, a másik tömbben az output iterátorokat. Legyen például a következõ a felépítés:
\begin{verbatim}
  template<typename T> struct 
  input_iterator_base { 
    typedef vect<T> value_type;
    typedef input_iterator_base iterator;
    // ...
    virtual value_type operator*();
    virtual iterator& operator++();
  };
  // output_iterator_base hasonlóan

  template<typename T> struct poly {
    struct input_iterator  : input_iterator_base<T> ;
    struct output_iterator : output_iterator_base<T> ;
    // ...
  };
  // reg_poly és circle hasonlóan
  
\end{verbatim}
Így bevezethetnénk az következõ változókat:
\begin{verbatim}
  class CGTLDrawDoc {
    list<input_iterator_base*>  input_iterators;
    list<output_iterátor_base*> output_iterators;
    // ...
  }
\end{verbatim}
De így már felesleges az algoritmusainkat függvény-sablonként implementál\-ni, ugyanis azt, hogy melyik paraméter \verb"input_iterator_base*" és melyik \verb"output_iterator_base*" típusú azt meg tudjuk már a program írásakor mondani. Így például a kirajzoló függvény lehetne a következõ:
\begin{verbatim}
  void Draw( list<input_iterator_base>& l, 
    Graphics& g, 
    Pen& p )
  {
    list<input_iterator_base>::iterator list_iter;
    input_iterator_base iterator save, iter;
    Point p1, p2;

    for(list_iter=l.begin(); list_iter!=l.end; list_iter++)
    {
      save = iter = *list_iter;
      p1 = p2 = ToPoint( *iter );

      do {
        iter++;
        p2 = ToPoint( *iter );
        g.DrawLine(&p, p1, p2);
        p1 = p2;
      } while(iter!=save);
     }
   }
\end{verbatim}

Ez már egy kompromisszumos megoldás, de túlzottan, sõt szinte kizárólag az öröklõdésre és az objektum orientált programozásra támaszkodik. Egyér\-telmû ennek a megközelítésnek a hátránya, mivel a iterátor léptetésnél és a \verb"*" operá\-tornál virtuális függvény hívás történik és ezek az alapvetõ mûveletek minden ciklusmagban meghívódnak. 

Sablonokkal viszont nem lehet megoldani, kivéve ha nem szimuláljuk valahogy a polimorfizmus, például \verb"void*"-ra konvertálva és megfelelõ meta-programozással biztosítani, hogy mindig a megfelelõ függvény hívódjon meg. Egy ilyen jellegû megoldás lehetne a következõ: 
\begin{verbatim}
  template<typename T> stuct node {
    poly<T>::input_iterator* poly_input_iter;
    poly<T>::output_iterator* poly_output_iter;
    // többi alakzatra hasonlóan
    node* next;
  }
\end{verbatim}
De ez nagyon csúnya megoldás lenne, mert igaz, hogy a tárolást megoldaná, és csak ezt a struktúrát kellene módosítani új típusú alakzat hozzáadásakor, de a \verb"node" kiolvasása okozna gondot, azaz egy bonyolult \verb"if/else" elágazást eredményezne, hogy polimorf szerû viselkedést produkáljon. Ez talán megkerülhetõ lenne meta-programozással, a \emph{Boost.Function}hoz hasonló megol\-dással.

\subsubsection{Konkluzió}
Végül gondoljuk át, általánosan, hogy mit is követelünk meg a GTL grafikus könyvtártól. Elsõ sorban azt várjuk el, hogy az alakzatokat hatékonyan ábrázolja és hogy ezekhez az alakzatokhoz biztosítson megfelelõ transzfor\-mációkat és algoritmusokat, másrészt legyen könnyen bõvíthetõ az alakzatok készlete és az algoritmusok készlete is. Ezeket lényegében teljesíti is a GTL. 

Ami hiányzik belõle, az a lehetõség, hogy az alakzatokat közös konténerbe lehessen helyezni és ezt fordítás-idejû, statikus polimorfizmussal, amit a generikus programozás nyújt, nem lehet megoldani. Tegyük fel, ugyanis, hogy van egy olyan ``ügyes konténerünk'', ami el tudná tárolni az alakzatokat és statikus polimorfizmusra támaszkodik. Ez azt jelentené, hogy fordítás-idõben el tudja dönteni, hogy milyen alakzattal fog bõvülni. Ez viszont egy rajzoló programban megengedhetetlen, ugyanis a rajzoló programban, a felhasználó csak futás-idõben fogja megadni, hogy milyen alakzatokat fog rajzolni. Elég csak az elsõ elemét megfigyelni ennek az ``ügyes konténernek'', még ha valahogy, el is tudja tárolni az alakzatot, és vissza is tudja adni, akkor is egy \verb"if" elágazással le kell kezelni külön-külön mindegyik alakzat esetét, mivel az volt a feltevés, hogy az alakzatok csak statikusan polimorfak és nincs közös bázisosztályuk.

Ha belegondolunk, világos, hogy dinamikus polimorfizmusra van szüksé\-günk. Az öröklõdés és a virtuális függvények pontosan azt a problémát oldják meg amivel szembesülünk. A virtuális függvények, abból a célból tervezték, hogy ha egy objektum típusának és viselkedésének mivoltát, el akarjuk halasztani futási-idõre, akkor ne kelljen bonyolult elágazás struktúrákat írni. 

Ennek a döntésnek az elhalasztásának ára van. Programozásban, mindig amikor késõbbre halasztunk egy döntés, azt valamivel kompenzálni kell. Ha csak futás idõben dõl el, hogy

Ha egy döntést, konkrétan azt, hogy milyen típusú objektum, milyen függvénye hívódik meg