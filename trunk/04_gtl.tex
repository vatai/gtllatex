\section{GTL}
Sokáig az STL volt az egyetlen a gyakorlatban hatékonyan alkalmazható generikus könyvtár. Az STL bemutatta a generikus programozás lehetõségei\-nek és erejének egy részét, de mivel nem volt más példa és összehasonlítási alap, nem igazán tapasztalhattuk meg a generikus programozás teljes erejét és korlátait sem. Többek között, ez volt az egyik oka a GTL kifejlesztésének.

A GTL-t, az STL mintájára irták, viszont most a konténereket alakzatok (\verb"poly", \verb"regpoly", \verb"circle" ) helyettesítik, az algoritmusokat pedig transzformációs mûveletek(\verb"move", \verb"rotate", \verb"mirror"). 

% \subsection{Alkalmazás és algoritmusok implementációja}

A két dimenziós alakzatokat a csúcsaikkal tudjuk leírni. A csúcsok pontok a síkban, vagyis két dimenziós vektoroknak is felfoghatjuk õket. A GTL a csúcsokat \verb"vect<T>" típusú osztály-sablonokkal írja le, ahol a \verb"T" egy \verb"double"-val kompatibilis típus. A \verb"vect<T>"-re definiálva vannak a szokásos mûveletek, mint például a konstruktor, értékadás, egyenlõség vizsgálat és kiíró operátor. Ezeken kívül definiálva van még az összeadás, a kivonás két \verb"vect<T>" között, \verb"T"-vel (skalárral) való szorzás és az origó körüli elforgatás \verb"double r" radiánnal. 

\subsection{Alakzatok}
A GTL három alakzatot definiál:
\begin{enumerate}
	\item Kör -- \verb"circle<T>"
	\item Sokszög -- \verb"poly<T>"
	\item Szabályos sokszög -- \verb"reg_poly<T>"
\end{enumerate}

\subsubsection{Kör -- circle}

Vizsgáljuk meg a kör implementációját részletesebben: 
\begin{verbatim}
template<typename T>
class circle
{
public:
  circle( const vect<T>& origo=0, const T sugar=0 ) 
    : o(origo), r(sugar) {}

  vect<T> o; // origo
  T r;       // sugar
  // ...
\end{verbatim}
A kör a \verb"vect<T> o;" csúccsal és a \verb"T r;" sugárral van reprezentálva. A konstruktor a megfelelõ módon inicializálja ezeket a változókat. Ha paraméter nélkül hívjuk meg a konstruktort, akkor egy $0$ sugarú kört kapunk az origón. Az iterátorokat ugorjuk egyenlõre át. Ez után következik pár segéd függvény:
\begin{verbatim}
template<typename T> class circle
{
public:
  // ...
  class input_iterator  { /* ... */ }; 
  class output_iterator { /* ... */ }; 

  void set( vect<T>& origo, T sugar )
  { o = origo; r = sugar; }

  input_iterator get_input_iter( int n=3 ) 
  { return input_iterator( o, r, n ); }
  
  output_iterator get_output_iter() 
  { return output_iterator(*this); }

  input_iterator null_input_iter() 
  { return input_iterator(); }
};
\end{verbatim}
A \verb"set()" metódussal tudjuk a sugarat és az origót közvetlenül módosítani, továbbá a többi alakzattól eltérõen a kör input iterátor lekérdezõ metódusa paraméterezhetõ, ahol a paraméter egy pozitív egész, és az iterátor finomsá\-gát adja meg. Az iterátor finomsága alatt azt kell érteni, hogy hány lépésben iterál végig a körön. Az alap értelmezett értéke ennek a paraméternek 0, és ekkor az origót adja vissza. % Ekkor lényegében egy szabályos háromszög csúcsain lépked végig az iterátor, de ez bõven elég egy kör pontos meghatározásához.

\subsubsection{Szabályos sokszög -- reg\_poly}

A szabályos sokszög implementációja se túl bonyolult (eltekintve az iterá\-torok implementációjától):
\begin{verbatim}
template<typename T> class reg_poly
{
public:
  vect<T> o; // origo
  vect<T> p; // egy csucs
  int n;     // csucsok szama

  reg_poly( 
    const vect<T>& origo=0, 
    const vect<T>& csucs=0, 
    int ncsucs=0 )
  : o(origo), p(csucs), n(ncsucs) {}

  // I/O iterátorok

  void set( vect<T>& origo, 
    vect<T>& csucs, int ncsucs )
  { o = origo; p = csucs; n = ncsucs; }

  int size() const { return n; }
  
  // iterátor lekérdezések
};
\end{verbatim}
A szabályos sokszöget hasonlóan reprezentáljuk mint a kört. A közép\-pont most is a \verb"vect<T> o;". Mivel nem kerek az alakzat, ezért nem elég csak a sugarat, hanem az egyik csúcsot is meg kell adni, ez most a \verb"vect<T> p;". Továbbá még a sokszög csúcsainak a számát is el kel tárolni az \verb"int n;" változóban. A konstruktor és a \verb"set()" hasonló mint a körnél. A szabályos sokszögnél értelmes a \verb"size()" függvény is, ami a csúcsok számát adja vissza, hasonlóan ahogy az STL konténerek az elemek számát. Az iterátor lekérdezé\-sek is hasonlóak mint a körnél.

\subsubsection{Sokszög -- poly}

A (szabálytalan) sokszög kissé máskép van implementálva. 
\begin{verbatim}
template<typename T> class poly
{
public:
  std::vector< vect<T> > v; // maguk a csucsok

  poly() {}

  // iterátorok és 
  // iterátor lekérdezések
  
  void add( vect<T>& csucs )
  { 
    v.push_back( csucs ); 
  }
  
  void del()
  { 
    if( size()>0 ) v.pop_back(); 
  }

  int size()
  {
    return v.size();
  }

};
\end{verbatim}
A sokszöget a \verb"vector< vect<T> > v;" változó reprezentálja, amelyben a sokszög csúcsait tároljuk. Csak alapértelmezett konstruktor van definiálva, az \verb"add()" metódussal bõvíthetjük a sokszöget egy új csúccsal, míg a \verb"del()" metódus törli az utolsó csúcsot. A \verb"size()" most is a csúcsok számát adja vissza.

\subsection{Iterátorok}
Ahogy az STL könyvtárnál már tapasztaltuk, az iterátorok kulcsfontosságú szerepe töltenek be. Mindegyik alakzatban, egy-egy alosztályként definiálva vannak a 
\begin{verbatim}
  class input_iterator{ /* ... */ };
  class output_iterator{ /* ... */ };
\end{verbatim}
iterátorok. Az elnevezés lehet, hogy nem éppen a legszerencsésebb, ugyanis nem az alakzatok, hanem az algoritmusok szempontjából néz\-ve kapták ezeket a neveket. Az input iterátor az amelyik az algoritmusok inputját biztosítja, vagyis a ``konstans'' iterátor, ami az alakzat pillanatnyi állapotát tükrözi. Az output iterátor pedig az algoritmusok outputját biztosítják, vagyis amikor ezekre alkalmazzuk a \verb"*" operátort akkor egy \verb"vect<T>&" referencia szerû objektumot adnak vissza, ami módosítható.

Érdemes megfigyelni, hogy mind három GTL alakzat, az STL konténerei\-vel szemben, nem lineáris hanem ciklikus. Ezért az iterátorok nem egy $[a,b)$ jellegû intervallumot járnak be, hanem körbejárják az alakzat csúcsait, és logikus, hogy az utolsó csúcs után, újra az elsõ következik. Ebbõl adódóan az alakzatok iterátorait célszerûbb ciklikus iterátoroknak, vagy cirkulátornak (circulator \cite{cgal}) nevezni.

Mivel nem lineáris iterátorokról van szó, hanem ciklikusakról, nincs külön eleje és vége az intervallumoknak amit bejárnak, hanem a \verb"begin()" és az \verb"end()" megegyezik. Ez miatt elég csak egy-egy metódus amelyik az input és output iterátort tudja lekérdezni. Ezek a következõk:
\begin{verbatim}
  input_iterator get_input_iter();
  output_iterator get_output_iter();
\end{verbatim}

% begin: TYPEDEF
\begin{table} 
\centering\small
\begin{tabular}{|rl|rl|}
\multicolumn{2}{c}{{\ttfamily input\_iterator}} &
\multicolumn{2}{c}{{\ttfamily output\_iterator}} \\ \hline
név 			& érték/típus 			& név 				& érték/típus\\ \hline
iterator 		& \verb"input_iterator" & iterator 			& \verb"output_iterator" \\
value\_type 	& \verb"vect<T>" 		& 	value\_type 	& \verb"vect<T>" \\
reference\_type & \verb"vect<T>&" 		& reference\_type 	& \verb"vect<T>&" \\
pointer\_type 	& \verb"vect<T>*" 		& pointer\_type 	& \verb"vect<T>*" \\
& &	const\_reference\_type & \verb"const vect<T>&" \\ \hline
\end{tabular}
\caption{Input és output iterátor typedef-ek}
\label{tab:typedef}
\end{table} % end: TYPEDEF

% begin: OPERATOR
\begin{table}[t] 
\centering\small
\begin{tabular}{|l|l|} \hline
\multicolumn{1}{|c|}{{\ttfamily input\_iterator}} & 
\multicolumn{1}{|c|}{{\ttfamily output\_iterator}} \\ \hline\hline
\verb"bool       operator==" 		& \verb"bool      operator=="\\
\verb"    (const iterator&)const" 	& \verb"    (const iterator&)const"\\ \hline
\verb"bool       operator!=" 		& \verb"bool      operator!="\\
\verb"    (const iterator&)const" 	& \verb"    (const iterator&)const"\\ \hline
\verb"value_type operator*()"		& \verb"iterator& operator*()" \\ \hline
\verb"iterator&  operator++()" 		& \verb"iterator& operator++()" \\ \hline
\verb"iterator   operator++(int)" 	& \verb"iterator& operator++(int)" \\ \hline
\verb"iterator&  operator--()"		& \verb"iterator& operator="\\ \cline{1-1} 
\verb"iterator   operator--(int)" 	& \verb"    (const_reference_type)"\\ \hline
\end{tabular}
\caption{Input és output iterátor operátorok}
\label{tab:operator} 
\end{table} % end: OPERATOR


%%%% ref nem jo mukodik
Mind három alakzatnak az iterátorai közös interfésze megtalálható a ~\ref{tab:typedef} és ~\ref{tab:operator} táblázatokban. Ezen kívül minden alakzat input iterátora rendelkezik két konstruktorral:
\begin{verbatim}
  input_iterator( ... ); // alakzattól függö paraméterek
  input_iterator(void);  // a null_iterator() adja vissza
\end{verbatim} 
Ezen kívül az input iterátorok biztosítanak még egy-egy
\begin{verbatim}
  null_iterator() { return input_iterator(); }
\end{verbatim} 
metódust is. A paraméter nélküli konstruktor egy érvénytelen objektum iterátorát hozza létre, azaz a \verb"null_iterator" egy ilyen iterátort ad vissza. Érvénytelen objektum alatt egy, valamilyen értelemben, null-objektumot ér\-tünk, mint például egy nulla sugarú kör vagy egy csúcs nélküli sokszög. Az elsõ (paraméteres) konstruktor, a megfelelõ alakzat csúcsain fog végig iterálni az \verb"operator++" és \verb"operator--" mûveletekkel és az \verb"operator*" operátorral lehet a csúcsot ábrázoló \verb"vect<T>" vektort lekérdezni. Az alakzatok input iterátor lekérdezõ \verb"get_input_iter()" metódusa, az iterátornak melyet létre hoz, át adja az összes szükséges adatott az alakzat leírásához. A körnél még a konstruktor paramétereként át lehet adni az iterátor ``finomságát'' is és ezek az iterátor adattagjaiban tárolódnak.

\subsection{Algoritmusok}
A GTL alakzataival végrehajtott algoritmusokat, aszerint, hogy módosítják-e az alakzatot, három csoportra oszthatjuk: 
\begin{enumerate}
	\item kizárólag ``olvasó'' algoritmusokra -- az \verb"input_iterator"t hasz\-nál\-ják.
	\item kizárolag ``író'' algoritmusok -- az \verb"output_iterator"ral módosítják az alakzatot.
	\item módosító algoritmusok -- ``író'' és ``olvasó'' algoritmusok egyszerre.
\end{enumerate}
Ezek közül az elsõ és a harmadik csoport a hasznosabb és a GTL ilyen jellegû algoritmusokat valósít meg. A második csoport azért nem igazán alkalmazható, mert az \verb"output_iterator"ok lényegében nem olvashatóak, és csak olyan algoritmusok tartoznának ide, mint például egy \verb"vect<T>[]" típusú tömbbõl egy alakzat elõállítása. Ezek az algoritmusok már nem a GTL konténereivel dolgoznának, így túlmutatnak eme könyvtár hatáskörén.

\subsubsection{Nemmódisító algoritmusok}

Példa kizárólag olvasó algoritmusra a GTL \verb"for_each" algoritmusa:
\begin{verbatim}
template<
  typename input_iterator, 
  typename Functor>
void for_each( input_iterator mit, Functor func )
  {
    input_iterator save = mit;
    func(*mit++);
    while(mit!=save)
    func(*mit++);
  }
\end{verbatim}
A \verb"for_each" algoritmus nagyon jól szemlélteti, hogyan kell írni egy algoritmust a GTL-hez: elmentjük az iterátort (pl. \verb"save" változóba) és elõ\-re olvasással addig iterálunk amíg körbe nem érünk (vagyis \verb"mit!=save"). Egyetlen függvény hívásnál nem szükséges, de ha nagyobb a \verb"while" ciklus törzse akkor a \verb"do...while()" konstrukció talán jobban illeszkedik az algoritmusok elõre-olvasó jellegéhez. Tehát a következõ implementáció talán kissé jobb:
\begin{verbatim}
void for_each( input_iterator mit, Functor func )
  {
    input_iterator save = mit;
    do { func(*mit++); }
    while(mit!=save);
  }
\end{verbatim}

Egy csomó ehhez hasonló, nem módosító, algoritmus található a GTL könyv\-tárban: 
\begin{description}
\item[\ttfamily void for\_each(input\_iterator i,Functor func)]
	Az iterátor által bejárt alakzat összes csúcsára meghívja az \verb"f" functort. 
\item[\ttfamily input\_iterator find( input\_iterator mit, Predicate pred )]
	Arra a csúcsra mutató\footnote{A kifejezés arra utal, hogy ha az iterátorra alkalmazzuk a dereferencia operátort, akkor pont típusú objektumot ad vissza. Ez a szóhasználat késõbb is megtalálható a dolgozatban és az iterátorok imént említett viselkedésére utal.} iterátort adja vissza, amelyre a \verb"pred" igaz.
\item[\ttfamily int count(input\_iterator it, Predicate pred)]
	Megszámolja, hogy az iterátor által bejárt csúcsok közül hányra teljesül \verb"pred".
\item[\ttfamily bool isomorph(input\_iterator1 i1, input\_iterator2 i2)]
	Két alakzat egyenlõ-e.
\item[\ttfamily value\_type weight\_point( input\_iterator mit )]
	Kiszámolja az alakzat súlypontját.
\end{description}

Ezek az algoritmusok csak az alakzat input iterátorát használják. Tipikussan a következõ módon alkalmazhatjuk õket (a példában egy sokszög, a koordináta rendszer elsõ kvadránsába esõ csúcsait a számoljuk):
\begin{verbatim}
bool quad1( vect<float> v )
{ return ( v.x >= 0 ) && ( v.y >= 0 ); }

void f( reg_poly<float> rp )
{
  int cnt;
  cnt = count( rp.get_input_iter(), quad1 );
  std::cout << "csúcsok száma: " << cnt << std::endl;
}
\end{verbatim}

\subsubsection{Módisító algoritmusok}

Módosító algoritmusok azok, amelyek párhuzamosan léptetnek egy input és egy output iterátort. Az egyiket olvassák és ennek alapján a másikat módosítják. A GTL a következõ módosító algoritmusokat biztosítja:
\begin{description}
\item[\ttfamily void move( ..., const\_reference\_type v )]
	Az alakzat eltolása \verb"v" vektorral.
\item[\ttfamily void mirror( ..., const\_reference\_type v )]
	A \verb"v" ponton áthaladó füg\-gõ\-leges tengelyre való tükrözés.
\item[\ttfamily void rotate( ..., double rad )]
	Az alakzat elforgatása az origó körül \verb"rad" fokkal.
\item[\ttfamily void inplace\_rotate( ..., double rad )]
	Az alakzat elforgatása a súly\-pontja körül, \verb"rad" fokkal.
\item[\ttfamily void clone( ... )]
	Az alakzat klónozása/másolása. \footnote{A {\ttfamily clone} egy speciális eset, ugyanis ezt nem \emph{egy} alakzat input és output iterátorára érdemes alkalmazni, hanem ha egy alakzatot egyenlõvé akarunk tenni a másikkal.}
\end{description}
A felsorolt függvény-sablonok paraméter listája nem teljes, ugyanis a \verb'...' helyén, az \verb"input_iterator mit, output_iterator hova" áll. Például a \verb"move" teljes függvény-sablon prototípusa:
\begin{verbatim}
  template<
    typename input_iterator, 
    typename output_iterator, 
    typename T>
  void move( 
    input_iterator mit, 
    output_iterator hova, 
    const vect<T>& v )
\end{verbatim}

A módosító algoritmusokra talán a \verb"move" a legegyszerûbb és legszemléle\-te\-sebb példa:
\begin{verbatim}
  void move( 
    input_iterator mit, 
    output_iterator hova, 
    const vect<T>& v )
  {
    input_iterator save = mit;
    do{ *hova++ = (*mit++) + v; }
    while( mit!=save )
  }
\end{verbatim}
Ezeket a mûveleteket tipikusan a következõ módon lehet alkalmazni (a példá\-ban a \verb"move" mûveletet alkalmazzuk egy körre):
\begin{verbatim}
  void f( circle<float> c, vec<float> v ) 
  {
    move( c.get_input_iter(), c.get_output_iter(), v );
  }
\end{verbatim}

Az eddig felsorolt, alap algoritmusok mintájára, nagyon könnyen lehet tetszõleges algoritmust implementálni. Láthatjuk, hogy az STL-hez hasonló\-an, csak az iterátorokat, és az algoritmushoz szükséges információt (functort vagy elforgatás szögét), kell átadni. 

