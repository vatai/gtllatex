\section{Egy kézenfekvõ megoldás -- öröklõdés}
Ha az ember geometriai alakzatokat rajzoló és manipuláló programot akar írni, akkor azt objektum orientált megközelítés, vagyis az öröklõdés jó vá\-lasz\-tás\-nak tûnik. A tipikus példa, az öröklõdés és az objektum orientált programozás szemléltetésére pontosan az ilyen rajzoló programok implementációja. Egy \verb'Shape' bázis-osztályból indulnánk ki és ebbõl származtatnánk a \verb'Polygon', \verb'Circle' és hasonló osztályokat. A \verb'Shape' osztályban deklaráljuk a virtuális \verb'draw', \verb'move', \verb'rotate', stb. metódusokat, majd a származtatott osztályokban definiáljuk õket és egy \verb'Shape*' típusú, azaz alakzatokra mutató mutatókat tartalmazó tömbbe pakoljuk a rajzlap tartalmát. Ilyen megoldással erõsen támaszkodunk az öröklõdésre és a dinamikus polimorfizmusra.

A Java elsõ kiadásai ezt a megközelítést alkalmazták a szabványos tárolók megvalósításához. Jávában minden típus az \verb'Object' típusból származik, azaz Jávában minden objektum típusú \cite{tij}. Így kézenfekvõ volt az a megoldás, hogy az \verb'ArrayList', a \verb'List', a \verb'Set' és a \verb'Map' konténerek \verb'Object' típusú elemeket (pontosabban referenciákat) tárolnak. Ennek egyértelmû hátránya volt, hogy a tárolók úgymond ``nem tudtak'' a tárolt elemek típusáról semmit. Továbbá amikor használták a konténer elemeit, akkor azok mivel \verb'Object' típusúak voltak, ezért futásidejû, dinamikus típuskonverziót kellet rajtuk végrehajtani ami valamilyen mértékben rontotta a program teljesítményét. Ezt ki lehetett kerülni új, ``típus-tudatos'' osztályok létrehozásával. Ilyen lehetne például a \verb'ShapeArray' osztály, amelyhez megírhatjuk a megfelelõ \verb'DrawAll(ShapeArray sa)' és \verb'RotateAll(ShapeArray sa, float r)' függ\-vé\-nyeket.

A konténereket és a rajtuk végrehajtandó algoritmusokat C++-ban nagyon elegáns módon oldották meg, generikus programozással, azaz sablon-osztályok és sablon-függvények segítségével. A C++ STL könyvtárában (Standard Template Library), a konténerek mint például a \verb'vector', a \verb'list', a \verb'set' stb. mind osztály-sablonok, melyeket a tárolandó elemek típusával paraméterezünk. Ezek mellé, az STL még a megfelelõ algoritmusokat is biztosítja, mint például a \verb'sort' vagy a \verb'find'. Ezek sablon függvényként vannak implementálva, és iterátorokon keresztül kommunikálnak a konténerek\-kel. Az STL-nek megközelítése számos elõnye van az \verb'Object'eket tároló konténerrel szemben:
\begin{itemize}
	\item Típus biztonságos: A fordító mindent elvégez helyettünk. Fordítási-idõben példányosítja a osztály-sablonokat és függvény-sablonokat, és a megfelelõ típus ellenõrzéseket is elvégzi. Tehát kisebb a hiba lehetõség.
	\item Hatékony: A sablonok segítségével a fordító mindent a fordítási idõben kiszámol, leellenõriz és behelyettesít -- minden a fordításkor eldõl semmit sem hagy futási-idõre.
	\item Egyszerûbb bõvíteni és programozni: akár új algoritmusokkal, akár új konténerekkel egyszerûen bõvíthetjük a könyvtárat, csak a megfelelõ iterátorokat kell implementálni és a megfelelõ konvenciókat (concept-eket) követni. 
\end{itemize}
Az utobbiból az is adódik, hogy ha van $m$ típusunk és $n$ mûveletünk, akkor az objektum orientál hozzáállással ellentétben, ahol minden típus minden (virtuális) metódusát, azaz $O(n*m)$ függvényt kell implementálni, generikus programozással viszont elég $O(n+m)$, vagyis külön-külön implementálnunk kell a típusokat (és iterátoraikat) és külön az algoritmusokat.

A GTL elkészítését az ösztönözte, hogy az alakzatok konténerekre, az transzformációs mûveletek pedig algoritmusokra hasonlítanak. A GTL úgy van felépítve mintha pontokat (pontosabban \verb'vect<T>' típusú elemeket) tároló konténerek lennének, és az alakzatok iterátorai ezeken a pontokon, azaz a csúcsokon iterálnak végig. 