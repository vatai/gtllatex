\section{A Generikus programozás kialakulása C++-ban}

\subsection{Egy kézenfekvõ megoldás -- öröklõdés}
Ha az ember geometriai alakzatokat rajzoló és manipuláló programot akar írni, akkor azt objektum orientált megközelítés, vagyis az öröklõdés jó vá\-lasz\-tás\-nak tûnik. A tipikus példa, az öröklõdés és az objektum orientált programozás szemléltetésére pontosan az ilyen rajzoló programok implementációja. Egy \verb'Shape' bázis-osztályból indulunk ki és ebbõl származtatjuk a \verb'Polygon', \verb'Circle' és hasonló osztályokat. A \verb'Shape' osztályban deklaráljuk a virtuális \verb'draw', \verb'move', \verb'rotate', stb. metódusokat, majd a származtatott osztályokban definiáljuk õket és egy \verb'Shape*' típusú, azaz alakzatokra mutató mutatókat tároló tömbbe pakoljuk a rajzlap tartalmát. Ilyen megoldással erõsen tá\-masz\-kodunk az öröklõdésre és a dinamikus polimorfizmusra.

A Java elsõ kiadásai ezt a megközelítést alkalmazták a szabványos tárolók megvalósításához. Jávában minden típus az \verb'Object' típusból származik, azaz Jávában minden \verb|Object| típusú \cite{tij}. Így kézenfekvõ volt az a megoldás, hogy az \verb'ArrayList', a \verb'List', a \verb'Set' és a \verb'Map' konténerek \verb'Object' típusú elemeket (pontosabban referenciákat) tárolnak. Ennek egyértelmû hátránya volt, hogy a tárolók úgymond ``nem tudtak'' a tárolt elemek típusáról semmit. Továbbá amikor használták a konténer elemeit, akkor azok mivel \verb'Object' típusúak voltak, ezért futásiidejû, dinamikus típuskonverziót kellet rajtuk végrehajtani ami valamilyen mértékben rontotta a program teljesítményét. Ezt ki lehetett kerülni új, ``típus-tudatos'' osztályok létrehozásával. Ilyen lehetne például a \verb'ShapeArray' osztály, amelyhez megírhatjuk a megfelelõ \verb'DrawAll(ShapeArray sa)' és \verb'RotateAll(ShapeArray sa, float r)' függ\-vé\-nyeket.

\subsection{Az elsõ generikus könyvtár}
A konténereket és a rajtuk végrehajtandó algoritmusokat C++-ban nagyon elegáns módon oldották meg,  osztály-sablon\-ok és függvények-sablon\-ok segít\-ségével. A C++ STL könyvtárában (Standard Template Library), a konté\-nerek mint például a \verb'vector', a \verb'list', a \verb'set' stb. mind osztály-sablonok, melyeket a tárolandó elemek típusával paramétere\-zünk. Ezek mellé, az STL még a megfelelõ algoritmusokat is biztosítja, mint például a \verb'sort' vagy a \verb'find'. Az algoritmusok függvény sablonként vannak implementálva, és iterátorokon keresztül ``kommunikálnak'' a konténerek\-kel. Az STL-nek megközelítése számos elõnye van az \verb'Object'eket tároló konténerrel szemben:
\begin{itemize}
	\item Típus biztonságos: A fordító mindent elvégez helyettünk. Fordítási-idõben példányosítja a osztály-sablonokat és függvény-sablonokat, és a megfelelõ típus ellenõrzéseket is elvégzi. Tehát kisebb a hiba lehetõség.
	\item Hatékony: A sablonok segítségével a fordító mindent a fordítási idõben kiszámol, leellenõriz és behelyettesít -- minden a fordításkor eldõl semmit sem hagy futási-idõre.
	\item Egyszerûbb bõvíteni és programozni: akár új algoritmusokkal, akár új konténerekkel egyszerûen bõvíthetjük a könyvtárat, csak a megfelelõ iterátorokat kell implementálni és a megfelelõ konvenciókat (concept-eket) követni. 
\end{itemize}
Az utobbiból az is adódik, hogy ha van $m$ típusunk és $n$ mûveletünk, akkor az objektum orientál hozzáállással ellentétben, ahol minden típus minden (virtuális) metódusát, azaz $O(n*m)$ függvényt kell implementálni, generikus programozással viszont elég $O(n+m)$, vagyis külön-külön implementálnunk kell a típusokat (és iterátoraikat) és külön az algoritmusokat.

Ezek az elõnyöket, az STL oly módon képes megvalósítani, hogy egyálta\-lán nem megy a programozó rovására, vagyis nem kell bonyolultabb kódot írni, sõt, kevesebb kódot kell írni, ami kevesebb hibával jár. A C++ sablonok, fordításkor manipulálják a kódot, és egy csomó rutin munkát elvégeznek a programozó helyett. Ebben az esetben, ahelyett, hogy mi írjuk meg külön-külön a \verb'IntVector'-t és a \verb'FloatVectort', a sablonok ezt automatikusan megteszik helyettünk, ugyanis lényegében ugyan azt a kódot kell megírni, csak más típussal.

