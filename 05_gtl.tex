\section{GTL}
Sokáig az STL volt az egyetlen a gyakorlatban hatékonyan alkalmazható generikus könyvtár. Az STL bemutatta a generikus programozás lehetõségei\-nek és erejének egy részét, de mivel nem volt más példa és összehasonlítási alap, nem igaza tapasztalhattuk meg a generikus programozás teljes erejét és korlátait sem. Többek között, ez volt az egyik oka a GTL kidolgozásának.

A GTL az STL mintájára irták, viszont most a konténereket alakzatok (\verb"poly", \verb"regpoly", \verb"circle" ) helyettesítik, algoritmusokat pedig transzformációs mûveletek(\verb"move", \verb"rotate", \verb"mirror"). 

\subsection{Alkalmazás és algoritmusok implementációja}

Az két dimenziós alakzatokat a csúcsaikkal tudjuk leírni. A csúcsok pontok a síkban vagyis két dimenziós vektoroknak is felfoghatjuk õket. A GTL a csúcsokat \verb"vect<T>" típusú osztály-sablonokkal írja le, ahol a \verb"T" egy \verb"double"-val kompatibilis típus. A \verb"vect<T>"-ra definiálva vannak a szokásos mûveletek, mint például a konstruktor, értékadás, egyenlõség vizsgálat és kiíró operátor. Ezeken kívül definiálva van még az összeadása, a kivonása két \verb"vect<T>" között, \verb"T"-vel (skalárral) való szorzás és az origó körüli elforgatás \verb"double r" radiánnal. 

\subsubsection{Alakzatok}
A GTL három alakzatot definiál:
\begin{enumerate}
	\item Kör -- \verb"circle<T>"
	\item Sokszög -- \verb"poly<T>"
	\item Szabályos sokszög -- \verb"regpoly<T>"
\end{enumerate}

Vizsgáljuk meg a kör implementációját részletesebben: 
\begin{verbatim}
template<typename T>
class circle
{
public:
  circle( const vect<T>& origo=0, const T sugar=0 ) 
    : o(origo), r(sugar) {}

  vect<T> o; // origo
  T r;       // sugar
  // ...
\end{verbatim}
A kört a \verb"vect<T> o;" csúccsal és a \verb"T r;" sugárral van reprezentálva. A konstruktor a megfelelõ módon inicializálja ezeket a változókat. Ha paraméter nélkül hívjuk meg a konstruktort, akkor egy $0$ sugarú kört kapunk az origón. Az iterátorokat ugorjuk egyenlõre át. Ez után következik pár segéd függvény:
\begin{verbatim}
template<typename T> class circle
{
public:
  // ...
  class input_iterator  { /* ... */ }; 
  class output_iterator { /* ... */ }; 

  void set( vect<T>& origo, T sugar )
  { o = origo; r = sugar; }

  input_iterator get_input_iter( int n=3 ) 
  { return input_iterator( o, r, n ); }
  
  output_iterator get_output_iter() 
  { return output_iterator(*this); }

  input_iterator null_input_iter() 
  { return input_iterator(); }
};
\end{verbatim}
A \verb"set()" metódussal tudjuk a sugarat és az origót közvetlenül módosítani, továbbá a többi alakzattól eltérõen a kör input iterátor lekérdezõ metódusa paraméterezhetõ, ahol a paraméter egy pozitív egész, és az iterátor finomsá\-gát adja meg. Az iterátor finomsága alatt az kell érteni, hogy hány lépésben iterál végig a körön. Az alap értelmezett értéke ennek a paraméternek 3. Ekkor lényegében egy szabályos háromszög csúcsain lépked végig az iterátor, de ez bõven elég egy kör pontos meghatározásához.

A szabályos sokszög implementációja se túl bonyolult (eltekintve az iterá\-torok implementációjától):
\begin{verbatim}
template<typename T> class reg_poly
{
public:
  vect<T> o; // origo
  vect<T> p; // egy csucs
  int n;     // csucsok szama

  reg_poly( 
    const vect<T>& origo=0, 
    const vect<T>& csucs=0, 
    int ncsucs=0 )
  : o(origo), p(csucs), n(ncsucs) {}

  // I/O iterátorok

  void set( vect<T>& origo, 
    vect<T>& csucs, int ncsucs )
  { o = origo; p = csucs; n = ncsucs; }

  int size() const { return n; }
  
  // iterátor lekérdezések
};
\end{verbatim}
A szabályos sokszöget szinte ugyan úgy reprezentáljuk mint a kört. A közép\-pont most is a \verb"vect<T> o;". Mivel nem kerek az alakzat, ezért nem elég csak a sugarat megadni, hanem az egyik csúcsot is meg kell adni, ez most a \verb"vect<T> p;". Továbbá még a sokszög csúcsainak a számát is el kel tárolni az \verb"int n;" változóban. A konstruktor és a \verb"set()" hasonló mint a körnél. A szabályos sokszögnél értelmes a \verb"size()" függvény is, ami a csúcsok számát adja vissza, hasonlóan ahogy az STL konténerek az elemek számát. Az iterátor lekérdezések is hasonlóak mint a körnél.

A (szabálytalan) sokszög kissé máskép van implementálva. 
\begin{verbatim}
template<typename T> class poly
{
public:
  std::vector< vect<T> > v; // maguk a csucsok

  poly() {}

  // iterátorok és 
  // iterátor lekérdezések
  
  void add( vect<T>& csucs )
  { 
    v.push_back( csucs ); 
  }
  
  void del()
  { 
    if( size()>0 ) v.pop_back(); 
  }

  int size()
  {
    return v.size();
  }

};
\end{verbatim}
A sokszöget a \verb"vector< vect<T> > v;" változó reprezentálja, amelyben a sokszög csúcsait tároljuk. Csak alapértelmezett konstruktor van definiálva, az \verb"add()" metódussal bõvíthetjük a sokszöget egy új csúccsal, míg a \verb"del()" metódus törli az utolsó csúcsot. A \verb"size()" most is a csúcsok számát adja meg.

\subsubsection{Iterátorok}
Ahogy az STL könyvtárban már tapasztaltuk, az iterátorok kulcsfontos\-ságúak lesznek. Mindegyik alakzatban, egy-egy alosztályként definiálva vannak a 
\begin{verbatim}
  class input_iterator{ /* ... */ };
  class output_iterator{ /* ... */ };
\end{verbatim}
iterátorok. Az elnevezés lehet, hogy nem épp a legszerencsésebb, ugyanis nem az alakzatok szempontjából, hanem az algoritmusok szempontjából nézve kapták ezeket a neveket. Az input iterátor az amelyik az algoritmusok inputját biztosítja, vagyis a ``konstans'' iterátor, ami az alakzat pillanatnyi állapotát tükrözi. Az output iterátor pedig az algoritmusok outputját biztosítják, vagyis amikor ezeket ezekre alkalmazzuk a \verb"*" operátort akkor egy \verb"vect<T>&" referencia szerû objektumot adnak vissza, amit módosítható.

Érdemes megfigyelni, hogy mind három GTL alakzat, az STL konténerei\-vel szemben, nem lineáris hanem ciklikus. Ezért az iterátorok nem egy $[a,b)$ jellegû intervallumot járnak be, hanem körbejárják az elem csúcsait, és logikus, hogy az utolsó csúcs után, újra az elsõre lépnek. Ebbõl adódóan az alakzatok iterátorait célszerûbb ciklikus iterátoroknak, vagy cirkulátornak (circulator \cite{cgal}) nevezni. 


Mivel nem lineáris iterátorokról van szó, hanem ciklikusakról, nincs külön eleje és vége az intervallumoknak amit bejárnak, hanem a \verb"begin()" és az \verb"end()" megegyezik. Ez miatt elég csak egy-egy metódus amelyik az input és output iterátort tudja lekérdezni. Ezek a következõk:
\begin{verbatim}
  input_iterator get_input_iter();
  output_iterator get_output_iter();
\end{verbatim}

% begin: TYPEDEF
\begin{table}[t]\centering\small
\begin{tabular}{|rl|rl|}
\multicolumn{2}{c}{{\ttfamily input\_iterator}} &
\multicolumn{2}{c}{{\ttfamily output\_iterator}} \\ \hline
név 			& érték/típus 			& név 				& érték/típus\\ \hline
iterator 		& \verb"input_iterator" & iterator 			& \verb"output_iterator" \\
value\_type 	& \verb"vect<T>" 		& 	value\_type 	& \verb"vect<T>" \\
reference\_type & \verb"vect<T>&" 		& reference\_type 	& \verb"vect<T>&" \\
pointer\_type 	& \verb"vect<T>*" 		& pointer\_type 	& \verb"vect<T>*" \\
& &	const\_reference\_type & \verb"const vect<T>&" \\ \hline
\end{tabular}\label{tab:typedef}
\caption{Input és output iterátor typedef-ek}
\end{table} % end: TYPEDEF

% begin: OPERATOR
\begin{table}[t]\centering\small
\begin{tabular}{|l|l|} \hline
\multicolumn{1}{|c|}{{\ttfamily input\_iterator}} & 
\multicolumn{1}{|c|}{{\ttfamily output\_iterator}} \\ \hline\hline
\verb"bool       operator==" 		& \verb"bool      operator=="\\
\verb"    (const iterator&)const" 	& \verb"    (const iterator&)const"\\ \hline
\verb"bool       operator!=" 		& \verb"bool      operator!="\\
\verb"    (const iterator&)const" 	& \verb"    (const iterator&)const"\\ \hline
\verb"value_type operator*()"		& \verb"iterator& operator*()" \\ \hline
\verb"iterator&  operator++()" 		& \verb"iterator& operator++()" \\ \hline
\verb"iterator   operator++(int)" 	& \verb"iterator& operator++(int)" \\ \hline
\verb"iterator&  operator--()"		& \verb"iterator& operator="\\ \cline{1-1} 
\verb"iterator   operator--(int)" 	& \verb"    (const_reference_type)"\\ \hline
\end{tabular}\label{tab:operator}
\caption{Input és output iterátor operátorok}
\end{table} % end: OPERATOR

Mind három alakzatnak az iterátorai közös interfésze megtalálható a \ref{tab:typedef} és \ref{tab:operator} táblázatokban. Ezen kívül minden alakzat input iterátora rendelkezik három konstruktorral:
\begin{verbatim}
  input_iterator( ... ); // alakzattól függö paraméterek
  input_iterator(void);  // a null_iterator() adja vissza
\end{verbatim} 
Ezen kívül az input iterátorok biztosítanak még egy-egy
\begin{verbatim}
  null_iterator() { return input_iterator(); }
\end{verbatim} 
metódust is. A paraméter nélküli konstruktor egy érvénytelen objektum iterátorát hoz létre, azaza a \verb"null_iterator" egy ilyen iterátort ad vissza. Érvénytelen objektum alatt egy, valamilyen értelemben, null-objektumot ér\-tünk, mint például egy nulla sugarú kör vagy egy csúcs nélküli sokszög. Az elsõ (paraméteres) konstruktor, a megfelelõ alakzat csúcsain fog végig iterálni az \verb"operator++" és \verb"operator--" mûveletekkel és az \verb"operator*" operatorral lehet a csúcsot ábrázoló \verb"vect<T>" vektort lekérdezni. Az alakzat \verb"get_input_iter()" metódusa, az iterátornak amit létre hoz, át adja az összes szükséges adatott az alakzat leírásához. A körnél még a konstruktor paramétereként át lehet adni az iterátor ``finomságát'' is és ezek az iterátor adattagjaiban tárolódnak.

\subsubsection{Algoritmusok}
A GTL alakzataival végrehajtott algoritmusokat, a szerint, hogy módosítják-e az alakzatot, három csoportra oszthatjuk: 
\begin{enumerate}
	\item kizárólag ``olvasó'' algoritmusokra -- az \verb"input_iterator"t hasz\-nál\-ják
	\item kizárolag ``író'' algoritmusok -- az \verb"output_iterator"ral módosítják az alakzatot
	\item módosító algoritmusok -- ``író' és ``olvasó'' algoritmusok egyszerre
\end{enumerate} A
Ezek közül az elsõ és a harmadik csoport a hasznosabb és a GTL ilyen jellegû algoritmusokat valósít meg. A második csoport azért nem igazán alkalmazható, mert az \verb"output_iterator"ok lényegében nem olvashatóak, és olyan algoritmusok tartoznak ide, mint például egy \verb"T[]" típusú tömb vagy\verb"vect<T>" vektorból elõállít egy alakzatot. Ezeknek az algoritmusok már nem a GTL konténereivel dolgoznának, így túlmutatnak egy könyvtár hatáskörén.

Példa kizárólag olvasó algoritmusra a GTL \verb"for_each" algoritmusa:
\begin{verbatim}
template<
  typename input_iterator, 
  typename Functor>
void for_each( input_iterator mit, Functor func )
  {
    input_iterator save = mit;
    func(*mit++);
    while(mit!=save)
    func(*mit++);
  }
\end{verbatim}
A \verb"for_each" algoritmus nagyon jól szemlélteti, hogyan kell írni egy algoritmust a GTL-hez: elmentjük az iterátort (pl. \verb"save" változóba) és elõ\-re olvasással addig iterálunk amíg körbe nem érünk (vagyis \verb"mit!=save"). Egy függvény hívásnál nem szükséges talán, de ha nagyobb a \verb"while" ciklus törzse akkor a \verb"do...while()" konstrukció talán alkalmasabb az algoritmus(ok) elõre-olvasó jellegéhez. Tehát talán a következõ implementáció talán kissé jobb:
\begin{verbatim}
void for_each( input_iterator mit, Functor func )
  {
    input_iterator save = mit;
    do { func(*mit++); }
    while(mit!=save);
  }
\end{verbatim}
Egy csomó ehhez hasonló, nem módosító, algoritmus található a GTL könyv\-tárban: 
\begin{description}
\item[\ttfamily void for\_each(input\_iterator i,Functor func)]
	Az iterátor által bejárt alakzat összes csúcsára meghívja az \verb"f" functort. 
\item[\ttfamily input\_iterator find( input\_iterator mit, Predicate pred )]
	Arra a csúcsra mutató iterátort adja vissza, amelyre a \verb"pred" igaza.
\item[\ttfamily int count(input\_iterator it, Predicate pred)]
	Megszámolja, hogy az iterátor által bejárt csúcsok közül hányra teljesül \verb"pred".
\item[\ttfamily bool isomorph(input\_iterator1 i1, input\_iterator2 i2)]
	Két alakzat egyenlõ-e.
\item[\ttfamily value\_type weight\_point( input\_iterator mit )]
	Kiszámolja az alakzat súlypontját.
\end{description}

Módosító algoritmusok azok, amelyek párhuzamosan léptetnek egy input és egy output iterátort és az egyiket olvassák és ennek alapján a másikat módosítják. A GTL a következõ módosító algoritmusokat biztosítja:
\begin{description}
\item[\ttfamily void move( ..., const\_reference\_type v )]
	Az alakzat eltolása \verb"v" vektorral.
\item[\ttfamily void mirror( ..., const\_reference\_type v )]
	A \verb"v" ponton áthaladó füg\-gõ\-leges tengelyre való tükrözés.
\item[\ttfamily void rotate( ..., double rad )]
	At alakzat elforgatása az origó körül \verb"rad" fokkal.
\item[\ttfamily void inplace\_rotate( ..., double rad )]
	At alakzat elforgatása a súly\-pontja körül, \verb"rad" fokkal.
\item[\ttfamily void clone( ... )]
	At alakzat klónozása/másolása. \footnote{A {\ttfamily clone} egy speciális eset, ugyanis ezt nem \emph{egy} alakzat input és output iterátorára érdemes alkalmazni, hanem ha egy alakzatot egyenlõvé akarunk tenni a másikkal.}
\end{description}


\subsection{Alkalmazás -- GTL Draw}

\subsubsection{Elõnyök}

\subsubsection{Hátrányok}

