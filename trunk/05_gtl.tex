\section{GTL}
Sokáig az STL volt az egyetlen a gyakorlatban hatékonyan alkalmazható generikus könyvtár. Az STL bemutatta a generikus programozás lehetõségei\-nek és erejének egy részét, de mivel nem volt más példa és összehasonlítási alap, nem igaza tapasztalhattuk meg a generikus programozás teljes erejét és korlátait sem. Többek között, ez volt az egyik oka a GTL kidolgozásának.

A GTL az STL mintájára irták, viszont most a konténereket alakzatok (\verb"poly", \verb"regpoly", \verb"circle" ) helyettesítik, algoritmusokat pedig transzformációs mûveletek(\verb"move", \verb"rotate", \verb"mirror"). 

\subsection{Alkalmazás és algoritmusok implementációja}

Az két dimenziós alakzatokat a csúcsaikkal tudjuk leírni. A csúcsok pontok a síkban vagyis két dimenziós vektoroknak is felfoghatjuk õket. A GTL a csúcsokat \verb"vect<T>" típusú osztály-sablonokkal írja le, ahol a \verb"T" egy \verb"double"-val kompatibilis típus. A \verb"vect<T>"-ra definiálva vannak a szokásos mûveletek, mint például a konstruktor, értékadás, egyenlõség vizsgálat és kiíró operátor. Ezeken kívül definiálva van még az összeadása, a kivonása két \verb"vect<T>" között, \verb"T"-vel (skalárral) való szorzás és az origó körüli elforgatás \verb"double r" radiánnal. 

\subsubsection{Alakzatok}
A GTL három alakzatot definiál:
\begin{enumerate}
	\item Kör -- \verb"circle<T>"
	\item Sokszög -- \verb"poly<T>"
	\item Szabályos sokszög -- \verb"regpoly<T>"
\end{enumerate}

Vizsgáljuk meg a kör implementációját részletesebben: 
\begin{verbatim}
template<typename T>
class circle
{
public:
  circle( const vect<T>& origo=0, const T sugar=0 ) 
    : o(origo), r(sugar) {}

  vect<T> o; // origo
  T r;       // sugar
  // ...
\end{verbatim}
A kört a \verb"vect<T> o;" csúccsal és a \verb"T r;" sugárral van reprezentálva. A konstruktor a megfelelõ módon inicializálja ezeket a változókat. Ha paraméter nélkül hívjuk meg a konstruktort, akkor egy $0$ sugarú kört kapunk az origón. Az iterátorokat ugorjuk egyenlõre át. Ez után következik pár segéd függvény:
\begin{verbatim}
template<typename T> class circle
{
public:
  // ...
  class input_iterator  { /* ... */ }; 
  class output_iterator { /* ... */ }; 

  void set( vect<T>& origo, T sugar )
  { o = origo; r = sugar; }

  input_iterator get_input_iter( int n=3 ) 
  { return input_iterator( o, r, n ); }
  
  output_iterator get_output_iter() 
  { return output_iterator(*this); }

  input_iterator null_input_iter() 
  { return input_iterator(); }
};
\end{verbatim}
A \verb"set()" metódussal tudjuk a sugarat és az origót közvetlenül módosítani, továbbá a többi alakzattól eltérõen a kör input iterátor lekérdezõ metódusa paraméterezhetõ, ahol a paraméter egy pozitív egész, és az iterátor finomsá\-gát adja meg. Az iterátor finomsága alatt az kell érteni, hogy hány lépésben iterál végig a körön. Az alap értelmezett értéke ennek a paraméternek 3. Ekkor lényegében egy szabályos háromszög csúcsain lépked végig az iterátor, de ez bõven elég egy kör pontos meghatározásához.

A szabályos sokszög implementációja se túl bonyolult (eltekintve az iterá\-torok implementációjától):
\begin{verbatim}
template<typename T> class reg_poly
{
public:
  vect<T> o; // origo
  vect<T> p; // egy csucs
  int n;     // csucsok szama

  reg_poly( 
    const vect<T>& origo=0, 
    const vect<T>& csucs=0, 
    int ncsucs=0 )
  : o(origo), p(csucs), n(ncsucs) {}

  // I/O iterátorok

  void set( vect<T>& origo, 
    vect<T>& csucs, int ncsucs )
  { o = origo; p = csucs; n = ncsucs; }

  int size() const { return n; }
  
  // iterátor lekérdezések
};
\end{verbatim}
A szabályos sokszöget szinte ugyan úgy reprezentáljuk mint a kört. A közép\-pont most is a \verb"vect<T> o;". Mivel nem kerek az alakzat, ezért nem elég csak a sugarat megadni, hanem az egyik csúcsot is meg kell adni, ez most a \verb"vect<T> p;". Továbbá még a sokszög csúcsainak a számát is el kel tárolni az \verb"int n;" változóban. A konstruktor és a \verb"set()" hasonló mint a körnél. A szabályos sokszögnél értelmes a \verb"size()" függvény is, ami a csúcsok számát adja vissza, hasonlóan ahogy az STL konténerek az elemek számát. Az iterátor lekérdezések is hasonlóak mint a körnél.

A (szabálytalan) sokszög kissé máskép van implementálva. 
\begin{verbatim}
template<typename T> class poly
{
public:
  std::vector< vect<T> > v; // maguk a csucsok

  poly() {}

  // iterátorok és 
  // iterátor lekérdezések
  
  void add( vect<T>& csucs )
  { 
    v.push_back( csucs ); 
  }
  
  void del()
  { 
    if( size()>0 ) v.pop_back(); 
  }

  int size()
  {
    return v.size();
  }

};
\end{verbatim}
A sokszöget a \verb"vector< vect<T> > v;" változó reprezentálja, amelyben a sokszög csúcsait tároljuk. Csak alapértelmezett konstruktor van definiálva, az \verb"add()" metódussal bõvíthetjük a sokszöget egy új csúccsal, míg a \verb"del()" metódus törli az utolsó csúcsot. A \verb"size()" most is a csúcsok számát adja meg.

\subsubsection{Iterátorok}
Ahogy az STL könyvtárban már tapasztaltuk, az iterátorok kulcsfontos\-ságúak lesznek. Mindegyik alakzatban, egy-egy alosztályként definiálva vannak a 
\begin{verbatim}
  class input_iterator{ /* ... */ };
  class output_iterator{ /* ... */ };
\end{verbatim}
iterátorok. Az elnevezés lehet, hogy nem épp a legszerencsésebb, ugyanis nem az alakzatok szempontjából, hanem az algoritmusok szempontjából nézve kapták ezeket a neveket. Az input iterátor az amelyik az algoritmusok inputját biztosítja, vagyis a ``konstans'' iterátor, ami az alakzat pillanatnyi állapotát tükrözi. Az output iterátor pedig az algoritmusok outputját biztosítják, vagyis amikor ezeket ezekre alkalmazzuk a \verb"*" operátort akkor egy \verb"vect<T>&" referencia szerû objektumot adnak vissza, amit módosítható.

Érdemes megfigyelni, hogy mind három GTL alakzat, az STL konténerei\-vel szemben, nem lineáris hanem ciklikus. Ezért az iterátorok nem egy $[a,b)$ jellegû intervallumot járnak be, hanem körbejárják az elem csúcsait, és logikus, hogy az utolsó csúcs után, újra az elsõre lépnek. Ebbõl adódóan az alakzatok iterátorait célszerûbb ciklikus iterátoroknak, vagy cirkulátornak (circulator \cite{cgal}) nevezni. 


Mivel nem lineáris iterátorokról van szó, hanem ciklikusakról, nincs külön eleje és vége az intervallumoknak amit bejárnak, hanem a \verb"begin()" és az \verb"end()" megegyezik. Ez miatt elég csak egy-egy metódus amelyik az input és output iterátort tudja lekérdezni. Ezek a következõk:
\begin{verbatim}
  input_iterator get_input_iter();
  output_iterator get_output_iter();
\end{verbatim}

Mind három alakzatnak az iterátorai a következõ interfészt nyújtja.
\begin{table}\begin{tabular}{|rl|rl|}
\multicolumn{4}{c}{{\ttfamily typedef}ek} \\
\multicolumn{2}{c}{{\ttfamily input\_iterator}} &
\multicolumn{2}{c}{{\ttfamily output\_iterator}} \\
\hline
név & érték/típus & név & érték/típus\\
\hline
\verb"iterator" & \verb"input_iterator" & 
	\verb"iterator" & \verb"output_iterator" \\
\verb"value_type" & \verb"vect<T>" & 
	\verb"value_type" & \verb"vect<T>" \\
\verb"reference_type" & \verb"vect<T>&" & 
	\verb"reference_type" & \verb"vect<T>&" \\
\verb"pointer_type" & \verb"vect<T>*" & 
	\verb"pointer_type" & \verb"vect<T>*" \\
& &
	\verb"const_reference_type" & \verb"const vect<T>&" \\
\hline
\end{tabular}\end{table}

\subsubsection{Algoritmusok}

\subsection{Alkalmazás -- GTL Draw}
\subsubsection{Elõnyök} 
\subsubsection{Hátrányok}
