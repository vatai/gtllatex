\section{Alkalmazás -- GTL Draw}
A GTL és ezzel a generikus programozás lehetõségeinek és korlátainak fel\-tárása céljából készült a \emph{GTL Draw} rajzoló program (egy korábbi munkám ami nagyprogramként lett bemutatva). A program a következõ funkciókat valósítja meg:
\begin{description}
	\item[Alakzatok rajzolása] Kör, sokszög és szabályos sokszögek rajzolása
	\item[Alakzatok módosítása] A már megrajzolt alakzatok módosítása, vagyis az alakzatok eltolása, forgatása és tükrözése.
\end{description}

\subsection{Az implementáció lényegesebb pontjai}

A GTL és a generikus programozás vizsgálat érdekében, a GTL Draw implementációjának következõ pontjait érdemes megemlíteni:
\begin{enumerate}
	\item \verb"double" lebegõpontos típussal van példányosítva mind három GTL alakzat. Ezért a \verb"double"ra be van vezetve \verb"typedef"fel egy \verb"scalar" szinonima. További szinonimák vannak bevezetve a példányosított alakzatokra és a vektorokra amelyekben tárolódnak:
	\begin{verbatim}
	typedef double scalar;
	typedef gtl::vect<scalar> Vect;

	typedef gtl::circle<scalar>		Circle;
	typedef gtl::poly<scalar>		Poly;
	typedef gtl::reg_poly<scalar>	RegPoly;

	typedef std::vector<Circle>		vCircle;
	typedef std::vector<Poly>		vPoly;
	typedef std::vector<RegPoly>	vRegPoly;
	\end{verbatim}
	\item A rajzlap tartalmát három vektor tárolja. Sorra \verb"vCircle", \verb"vPoly" és \verb"vRegPoly" típusú \verb"m_vCircle", \verb"m_vPoly" és \verb"m_vRegPoly" vektorok tárolja a megfelelõ alakzatot.
	\item A program hat lényegesebb állapotban lehet: három állapot jellemzi a három alakzat rajzolását, három másik állapot pedig a három transzformáció végrehajtását.
	\item A program lekezel minden eseményt. Ezek közül a kattintás a rajzlapra a legösszetettebb, az állapot függvényében, a következõ történik: 
	\begin{itemize}
	\item Ha alakzatot rajzolunk, akkor a megfelelõ vektor bõvül egy alakzattal.
	\item Ha transzformációs mûveletet hajtunk végre, akkor elõször végig\-keresi a program mind három vektort, hogy volt-e találat (alakzatra kattintottunk-e). Ha találat volt akkor az alakzat címét, amelyre rá lett kattintva, a \verb"Circle* pc", \verb"Poly* pp" és \verb"RegPoly*" \verb"rp" mutató közül, a megfelelõben tárolja és a másik kettõt nullára állítja. Majd mind a három mutatóra (pontosabban a mutató által mutatott alakzatra) meghívódik a megfelelõ algoritmus feltéve, hogy a mutató nem nulla.
	\end{itemize}
	\item Amikor szükség volt rá, három \verb"Draw" sablon függvény hívással kirajzolódtak a három vektorban tárolt alakzatok.
\end{enumerate}

A programmal implementáció részletes leírása megtalálható az \cite{gtldraw} címen, a \emph{doc} könyvtár alatt. 

{\bfseries Fontos megszorítás} volt, hogy a GTL Draw program megírásakor, a generikus programozás tanulmányozása érdekében, abszolút kikötés volt, kizáróla\-gosan sablonok, illetve sablon könyvtár használata. Azt tapasztaltam, a program írása során, hogy a (szigorúan) generikus programozás, vagyis ezen megszorítások és kikötések mellet, nem teljesen alkalmas egy ilyen rajzprogram megírásához. A generikus könyvtár nagyon nagy erõvel bír és óriási lehetõség rejlik benne, de dinamikus polimorfizmus nélkül komoly gondot okoz a különbözõ típusú alakzatok (konténerek) tárolása, ugyanis nem lehet õket egy közös konténerbe tenni. Megpróbálhatjuk elemezni a GTL Draw-ban alkalmazott generikus programozás elõnyeit, de ez elég ambivalens és vitatható eredményekhez vezet.

\subsection{Elõnyök}
A generikus programozás egy olyan programozási paradigma, mely meta-programozásra épül, azaz fordítás idejû programozásra. Így amit el tudunk dönteni, ki tudunk szûrni fordítási idõben, azt egy jól megírt meta-program vagy generikus sablon könyvtár, el intézi nekünk, vagyis gondoskodik amirõl bír. A generikus programozásnak általános elõnyei:
\begin{itemize}
	\item Típus biztonság
	\item Hatékonyság
	\item Egyszerû kód
\end{itemize}

\subsubsection{Típus biztonság}
A típus biztonság egyértelmûen teljesül. Sehol se nincs a programban semmiféle típuskonverzió, minden objektumnak jól definiált típusa van. Ez\-eknek a típusokkal megfelelõen példányosítódnak a megfelelõ függvény sablonok. Ha nem jó típusú objektumot adunk át, akkor azt a fordító rögtön jelzi, és a program nem  fordul le. 

Ez alól egy apró kivétel a mutatók használata, de azok csak lokális válto\-zóként szerepeltek és könnyû belegondolni hogyan lehet megkerülni a mutatók használatát. Viszont még így is csak az okozhatott hibát futás idejû hibát ha a null mutatóra hívjuk meg az algoritmust, de ezt könnyen ki lehet kerülni.

\subsubsection{Hatékonyság}
A hatékonyság abból adódik, hogy teljes mértékben el van kerülve az öröklõ\-dés, a virtuális függvények és a típus konverziók. A fordító program, például az alakzatok kirajzolásakor, fordítás-idõben létrehozza a megfelelõ kódot, ami futás idõben lefut. 

Konkrét mérések nem voltak, részben azért is mert nem volt mihez. Attól függetlenül, hogy nincsenek, ``rejtett'' konverziók és ``rejtett'' virtuális függvények (azaz függvény hívások) a programban, és a program pontosan azt fogja csinálni amit le van kódolva, csak ``bõvebben kifejtve'', látszik, hogy pár dolog talán ront egy picit a teljesítményen. Itt újra fel lehet hozni a mutatókat, és a null mutató vizsgálatát.

\subsubsection{Egyszerûbb kód}
Ez a legvitathatóbb ``elõny'', ugyanis mivel az egyetlen rajzlap tartalmát három különbözõ vektorban kell tárolni, nem igazán mondható elegáns és egyszerû megoldásnak. Ez annak a következménye, hogy teljes mértékben mellõztük az öröklõdést és nincs egy õsosztályunk, ami tudna kör is, sokszög is és szabályos sokszög is lenni, és ilyen típusú vektorban vagy listában tárolhatnánk a rajzlap tartalmát. Ezért minden mûveletet, mint például a kirajzolás, a ``találat keresés'' (annak az alakzatnak a keresése, amelyre rákattintottunk), háromszor kell végrehajtani, különbözõ paraméterrel. A mutatós komplikációkat nem is említve.

Az viszont meg kell jegyezni, hogy igaz, hogy háromszor kellet meghívni, például a \verb"Draw" függvényt, de csak egyszer kellet megírni és mindhárom alakzatra mûködött. Pontosabban kettõ \verb"Draw" függvény lett implementálva, ugyanis a kört, egy specializált \verb"Draw" függvény sablon rajzolta ki. Ezt is talán a hatékonyabb kódolásnak lehet tekinteni, mivel lehetõséget nyújtott, a megjelenítõ keretrendszer kör-rajzoló függvény alkalmazására, de ugyanakkor, az általános \verb"Draw" függvény sablon is ki rajzolta volna a kört\footnote{Az iterátor finomságán tudunk állítani, ha az input iterátor lekérdezõ függvényt egy paraméterrel látjuk el. Elég nagy finomság mellet, elvileg azonos eredményt érünk el.}, csak lassabban.

\subsection{Hátrányok}
Ahogy már korábban is meg lett említve, a fõ hátrány az, hogy a sablonok által generált osztályok teljesen függetlenek egymástól. Nincs közös õsosztályuk, és ezért nem lehet egyszerre, úgymond ``egy kalap alatt'' kezelni õket. Hiányzik az a lehetõség, hogy például egy \verb"list<Shape*>" listában tároljuk õket. Ez ahhoz vezet, hogy a három különbözõ típushoz, három különbözõ változóra van szükség. 

A program írásának legkényelmetlenebb része volt a kiválasztott alakzat elmentése. Ugyanis nem volt elég csak azt elmenteni, hányadik alakzat a tömbben, hanem azt is ki kell valahogy találni, hogy melyik tömbben. Ezt persze csak úgy lehet, hogy mind a három tömböt végig kell nézni elõtte. Utána meg három mutató közül kell kiválasztani azt, hogy melyik az érvényes. 

\subsection{A polimorfizmus megkerülhetetlensége}
Az a kérdés merülhet fel bennünk, sõt fel is kell, hogy merüljön: \emph{Meg lehet-e ezt a problémát oldani generikus programozással, vagyis sablon meta-progra\-mozással?} A válasz erre egyáltalán nem triviális és azt fogjuk belátni, hogy a válasz erre a kérdésre nemleges.

\subsubsection{Generikus programozás egy definíciója}
David R. Musser, a generikus programozás egyik úttörõje, a honlapján azt írja a generikus programozás definíciójáról, hogy az: ``programming with concepts'', azaz programozás conceptekkel. Az angol concept, illetve a conception szó jelentése magyarul: fogalom, elgondolás, elképzelés, eszme, felfogás. Viszont a concept szónak egy új értelmezése is született a közelmúltban. Concept fogalmát nemrég vezeték be a C++-ba. Még hivatalosan a concept ellenõrzés nem része a szabványnak de hamarosan az lesz.

A concept a sablonoknál olyasmi, mint az interfész az öröklõdésnél. Ha adott egy sablon, melynek egy van egy nem specializált \verb"T" típus változója, akkor concept-ekkel lehet meghatározni azt, hogy mit várunk el a \verb"T" típus helyén példányosítandó típustól. 

Például az iterátoroktól elvárjuk, hogy lehessen léptetni (\verb"operator++"), lehessen az értékét lekérdezni (\verb"operator++") és lehessen egyenlõséget illetve egyenlõtlenséget vizsgálni (\verb"operator==" és \verb"operator!="). Ezeknek a pontos meghatározása az algoritmusok alkalmazásánál nagyon hasznos lenne, ugyanis a C++ mai eszközei, nem teszik lehetõvé, hogy egy nem általunk írt könyvtár generikus algoritmus paramétereirõl bármit tudjunk. Ha egy egyszerû függvényt hívunk meg, a szignatúrája mindent elmond a paraméterei\-rõl, míg egy sablon deklaráció csak azt árulja el, hogy hány különbözõ paraméter\-rel lehet példányosítani, és hogy ezek közül melyik egy típusnév és melyik egy bizonyos meghatározott típusú értékek. A concept-ek specifikálnák, hogy egy objektum típusának, amellyel egy sablont szeretnénk példányosítani, milyen metódusokat kell, hogy implementáljon és milyen altí\-pusokat és \verb"typedef"eket kell hogy tartalmazzon.

A generikus programozás ereje, abban rejlik, hogy ha az adatszerkezeteinket ``hasonlóan'' írjuk meg, vagyis úgy, hogy megfeleljenek bizonyos concept-eknek, akkor könnyû ezekre az adatszerkezetekre olyan algoritmusokat írni, melyek függvénysablonokként vannak implementálva. A generikus programozással megvalósított algoritmusok, szintaktikailag lényegében azonosak, csak a paraméterek típusában különböznek. Ebbõl adódóan, a fordító program, legenerálja nekünk azt a kódot amire nekünk szükségünk van, de a döntéseket nem halaszthatjuk el futás-idõre. A sablonok kizárólag fordítási idõben játszanak szerepet. 

Ezért van az, hogy a generikus programozás fõ alkalmazási területe a könyvtárak fejlesztése mivel ott a leghatékonyabb. Konkrét program írásá\-nál, nem nagyon fogunk generikus programozást használni, ugyanis ott már in\-kább a generikus programozás gyümölcseit (a generikus könyvtárakat) fogjuk hasz\-nálni. Egy programozó nem fog csakis azért iterátorokat implementálni és meta-programokat írni, hogy egy konkrét feladathoz, egy konkrét problémát megoldjon. A generikus programozás csakis akkor kifizetõdõ stra\-tégia, ha nagymértékben újrahasználható, hatékony kódot szeretnénk létre\-hozni. Talán úgy lehetne, a generikus programozásra gondolni, mint az objektum orientált programozás megfelelõjére, azzal a különbségekkel, hogy a generikus programozás könyvtárak fejlesztésére alkalmasabb mivel a fordításig halasztja a döntéseket, hogy a könyvtár felhasználja az alkalmazás írásakor dönthesse el hogyan valósítja meg a programot, míg az objektum orientált programozás alkalmazások fejlesztésére alkalmasabb mivel futás-idõre halasztja el a döntéseket, hogy az alkalmazás felhasználja, futás-idõben mondja meg, mit csináljon a program.

\subsubsection{GTL kontra STL}
Elsõ ránézésre a GTL-t nem nehéz megírni az STL analógiájára, viszont ha jobban szemügyre vesszük, akkor lényeges különbségeket fedezhetünk fel a két könyvtár között. Az analógia szembetûnõ és nagyon egyszerû: 
\begin{itemize}
	\item A GTL alakzatai, az STL konténereinek felelnek meg.
	\item A GTL algoritmusai az alakzatokra vannak megírva, míg az STL algoritmusai a konténerekre.
	%\item A GTL algoritmusai grafikus jellegûek, míg az STL algoritmusai álta\-lános célú adat manipulációra szolgálnak.
\end{itemize}

Viszont ha belenézünk a GTL forrásába, akkor az elsõ szembetûnõ dolog a \verb"vect<T>" osztály sablon. Mivel síkbeli alakzatokat szeretnénk ábrázolni és mivel az alakzatokat a jellegzetes pontjaikkal határozhatjuk meg (csúcsok, középpont), ezért szükség van a pont definíciójára, amit egy valamilyen számtest feletti 2 dimenziós \footnote{Természetesen nem lenne nehéz megvalósítani az $n$ dimenziós, általános esetet.} vektortér eleme ábrázol. Továbbá a \verb"vect<T>" \verb"rotate" metódusában megfigyelhetõ. hogy a \verb"T" egy olyan numerikus típus kell, hogy legye, amely \verb"double"ra konvertálható. 

A GTL úgy van elképzelve, hogy az alakzatok olyan konténerek amelyek pontokat tárolnak. Tehát attól függetlenül, hogy paraméterezhetõ osztály-sablonként vannak implementálva, a paraméter nem fogja meghatározni mit fog tárolni, ugyanis mindig pontokat tárol, sõt \verb"double"ra konvertálható \verb"T" típussal példányosított \verb"vect<T>" vektorokat. Ez feltûnõen elüt az STL sokoldalúságától és flexibilitásától, mivel az STL konténerei bármilyen típusú objektumokat tárolhatnak.

% \subsubsection{A közös típus problémája}
% Ez már korábban is felvetõdött és ez volt az elsõdleges probléma, egy alakzat bázisosztályszerû típus létezése. Ha egy ilyen létezne, akkor nem lenne semmi gond, és minden probléma megoldódna. Egyszerûen a már korábban említett módon, mindent egy alakzatokat tároló listába pakolnánk, és ennek a lista elemeit rajzolnánk ki. 

% Ezzel a megoldással viszont, azt elvárnánk, hogy ha a list egy eleme, vagyis egy alakzat valójában egy sokszög, akkor egyféleképpen viselkedjen, ha viszont egy kör akkor másképpen viselkedjen. Ez viszont virtuális függvény hívás, vagy azzal azzal ekvivalens. Ugyanis tegyük fel, hogy két alakzat van a rajzlapon. Az elsõrõl tudjuk, hogy egy szabályos sokszög, de a második pedig sokszög vagy kör, attól függõen, hogy mire kattintottunk, vagyis csak futás-idõben dõl el, és a fordító biztos nem tud róla. Ekkor ugyebár a listánk két elemû lesz, az elsõ elem egy szabályos sokszög, a második pedig vagy 

% \subsubsection{A composite típus problémája}
% Egy alternatív megoldás lenne, ha nem feltétlenül egy \verb"Shape*[]" tömbben tárolnánk az alakzatokat, hanem létezne egy olyan objektum amibe tetszõleg\-es alakzatokat pakolhatnánk, például egy \verb"Group" vagy \verb"Composite" típusú objektum. Nem nehéz belátni, hogy ha létezne ilyen objektum, akkor ényegében minden gondot megoldana. Ha valahogy össze tudnák forrasztani a különbö\-zõ típusokat/alakzatokat, akkor ezeket egy vektorba tárolhatnánk, és az lenne az összetett típus, vagyis fordítva, ha létezne ilyen típus, akkor egy ilyen típusú objektumra hívnánk meg a függvényeinket. Például a kirajzolás szempontjából, a közös típus létezése 