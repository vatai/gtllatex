\section{Egy kézenfekvõ megoldás -- öröklõdés}
Ha az ember geometriai alakzatokat rajzoló és manipuláló programot akar írni, akkor azt objektum orientált megközelítés, vagyis az öröklõdés jó vá\-lasz\-tás\-nak tûnik. A tipikus példa, az öröklõdés és az objektum orientált programozás szemléltetésére pontosan az ilyen rajzoló programok implementációja. Egy \verb'Shape' bázis-osztályból indulunk ki és ebbõl származtatjuk a \verb'Polygon', \verb'Circle' és hasonló osztályokat. A \verb'Shape' osztályban deklaráljuk a virtuális \verb'draw', \verb'move', \verb'rotate', stb. metódusokat, majd a származtatott osztályokban definiáljuk õket és egy \verb'Shape*' típusú, azaz alakzatokra mutató mutatókat tároló tömbbe pakoljuk a rajzlap tartalmát. Ilyen megoldással erõsen támaszkodunk az öröklõdésre és a dinamikus polimorfizmusra.

A Java elsõ kiadásai ezt a megközelítést alkalmazták a szabványos tárolók megvalósításához. Jávában minden típus az \verb'Object' típusból származik, azaz Jávában minden \verb|Object| típusú \cite{tij}. Így kézenfekvõ volt az a megoldás, hogy az \verb'ArrayList', a \verb'List', a \verb'Set' és a \verb'Map' konténerek \verb'Object' típusú elemeket (pontosabban referenciákat) tárolnak. Ennek egyértelmû hátránya volt, hogy a tárolók úgymond ``nem tudtak'' a tárolt elemek típusáról semmit. Továbbá amikor használták a konténer elemeit, akkor azok mivel \verb'Object' típusúak voltak, ezért futásiidejû, dinamikus típuskonverziót kellet rajtuk végrehajtani ami valamilyen mértékben rontotta a program teljesítményét. Ezt ki lehetett kerülni új, ``típus-tudatos'' osztályok létrehozásával. Ilyen lehetne például a \verb'ShapeArray' osztály, amelyhez megírhatjuk a megfelelõ \verb'DrawAll(ShapeArray sa)' és \verb'RotateAll(ShapeArray sa, float r)' függ\-vé\-nyeket.
